<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfdlugHt.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.UPCtyyuv.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.CjDcszOu.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.5WXdMwYP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.CKJppIQ_.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-primary_index.md.CAZxxJZr.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-primary_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">75. Vue 项目中如何实现多环境配置？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>可以使用 .env 文件来为不同环境配置变量。常见的环境文件包括：</p>
<p>env：默认的环境配置（用于开发环境或没有明确环境时）。</p>
<p>.env.development：开发环境配置。</p>
<p>.env.production：生产环境配置。</p>
<p>.env.test：测试环境配置。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. == 和 ===区别，什么情况⽤ ==</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> ===⽤于判断两者类型和值是否相同。在开发中，对于后端返回的 code，可以通过 == 去判断</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22.讲一下EventEmitter？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Node.js 的大多数核心模块都是基于EventEmitter实现的，如 http、net、fs，很多第三方库也是基于EventEmitter实现的，如socket.io、nodemailer、cheerio等。</p>
</li>
<li><p>使用EventEmitter的好处是可以用事件的形式来处理异步任务，可以大大简化代码，并且容易处理异常。</p>
</li>
<li><p>举个例子来看看为什么Nodejs里大多数模块都要继承EventEmitter。</p>
</li>
<li><p>这是不使用EventEmitter实现的文件读取，所有逻辑都放在一个回调函数里：</p>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Failed to read file: <span class="hljs-subst">${err}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`File content: <span class="hljs-subst">${data}</span>`</span>);
  }
});
</code></pre><ul>
<li>这是使用EventEmitter的文件读取：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-keyword">const</span> stream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>);

stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received <span class="hljs-subst">${chunk.length}</span> bytes of data.`</span>);
});

stream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Finished reading file.&#x27;</span>);
});
</code></pre><ul>
<li>很显然，使用EventEmitter之后，处理文件和处理异常的逻辑就被分开了，代码可读性和可维护性都提升了。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. React 中如何处理事件？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> React 事件处理的方式与原生 JavaScript 不同，React 使用事件委托来优化性能，并且事件名称采用驼峰命名法。</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">event</span>) =&gt; {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);
  };

  <span class="hljs-keyword">return</span> &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
}
</code></pre><ul>
<li><strong>1：</strong> React 会自动绑定事件处理函数。</li>
<li><strong>1：</strong> 事件对象会被 React 规范化。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">进程和线程的区别?</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>. 进程是系统分配资源的基本单位，它包含独立的地址空间、资源表、堆栈、程序计数器等，每个进程都有独立的内存空间和系统资源。而线程是进程的一个实体，是CPU调度和分派的基本单位，线程只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li><p>. 由于线程共享进程的内存空间和资源，因此线程间的切换开销小，有利于并发执行。而进程间的切换需要涉及系统资源（如内存、打开的文件等）的分配与回收，开销较大。</p>
</li>
<li><p>进程是独立运行的，拥有独立的系统资源，包括内存、CPU时间、磁盘空间等。而线程只是进程的一个执行路径，共享进程的资源，因此线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉。</p>
</li>
<li><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，涉及当前执行进程CPU环境的保存、新调度进程CPU环境的设置、各种进程资源状态的更改（如内存管理中的数据段、堆栈段和指针的更改）等，而线程切换只需保存和设置少量寄存器内容，不涉及存储管理等方面的操作。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">66. 如果new一个箭头函数的会怎么样?</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
</li>
<li><p>new操作符的实现步骤如下：</p>
</li>
<li><p>1.创建一个对象</p>
</li>
<li><p>2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</p>
</li>
<li><p>3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</p>
</li>
<li><p>4.返回新的对象</p>
</li>
<li><p>由于箭头函数没有自己的this，用new调用会报错！所以，上面的第二、三步，箭头函数都是没有办法执行的。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">22. CommonJS和ES6模块的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>CommonJS模块是同步加载的，ES6模块是异步加载的。</p>
</li>
<li><p>CommonJS模块的导出是值的拷贝，ES6模块的导出是值的引用。</p>
</li>
<li><p>CommonJS模块的导入是动态的，ES6模块的导入是静态的。</p>
</li>
<li><p>CommonJS模块的导出是函数时，导出的函数是值的拷贝，ES6模块的导出是函数时，导出的函数是值的引用。</p>
</li>
<li><p>CommonJS模块的导出是对象时，导出的对象是值的拷贝，ES6模块的导出是对象时，导出的对象是值的引用。</p>
</li>
<li><p>CommonJS模块的导出是类时，导出的类是值的拷贝，ES6模块的导出是类时，导出的类是值的引用。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. display的block、inline和inline-block的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. Vuex和单纯的全局对象有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">26. Vue的路由实现, hash路由和history路由实现原理说一下？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p><code>location.hash</code>的值实际就是URL中<code>#</code>后面的东西。</p>
<p>history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. head 标签有什么作用，其中什么标签必不可少？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：base, link 等。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. Proxy 的使用</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>4：</strong> 部分 API</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e08a8f141f44148ad6f66c7fdc1ab3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<ul>
<li><strong>1：</strong> 函数调用的监听</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哈哈哈&quot;</span>);
}

<span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(fun, {
    <span class="hljs-comment">/**
     * 拦截对函数的调用的捕获器
     * <span class="hljs-doctag">@param</span> target target new Proxy 所代理的 obj（监听的对象）
     * <span class="hljs-doctag">@param</span> thisArg 调用函数时绑定的 this 值
     * <span class="hljs-doctag">@param</span> argArray 调用函数时传递的参数列表
     */</span>
    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argArray</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;对 fun 函数进行了 apply 的调用。&quot;</span>);
        <span class="hljs-comment">// 调用原始函数，并在其结果前后添加一些内容</span>
        target.<span class="hljs-title function_">apply</span>(thisArg, argArray)
    },
    <span class="hljs-comment">/**
     * 监听 class 时的捕获器
     * <span class="hljs-doctag">@param</span> target target new Proxy 所代理的 obj（监听的对象）
     * <span class="hljs-doctag">@param</span> argArray new fun() 时传入的参数，例：new fun(1, 2, ...rest)
     * <span class="hljs-doctag">@param</span> newTarget 被调用的构造函数。在这里，newTarget 就是 objProxy 本身，因为 objProxy 是一个函数代理
     */</span>
    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argArray, newTarget</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;对 fun 函数进行了 construct 的调用。&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">target</span>(...argArray)
    }
});

objProxy.<span class="hljs-title function_">apply</span>();
<span class="hljs-keyword">new</span> <span class="hljs-title function_">objProxy</span>();
</code></pre><ul>
<li><strong>1：</strong> new Proxy 中 receiver 参数的作用</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;里斯&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>,
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
    },
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span> = newValue;
    }
};

<span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {
    <span class="hljs-comment">/**
     * receiver 就是 objProxy 这个代理对象
     * receiver 传入 Reflect.get 之后，他就作为 obj 里的 this 了（this 这个时候就改变了）
     *
     */</span>
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver);
        <span class="hljs-comment">/**
         * 传入 receiver 后，他被访问了两次
         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);
    },
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) {
        <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);
    }
});

objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;哈哈哈&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>);
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">18. TypeScript中的映射类型是什么？请举例说明</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><p><strong>2：</strong> 映射类型允许你从一个旧类型创建一个新类型，其中新类型的每个属性都基于旧类型的属性进行转换。TypeScript内置了几个常用的映射类型。</p>
</li>
<li><p><strong>2：</strong> 示例：</p>
</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 原始接口</span>
interface <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">name</span>: string;
    <span class="hljs-attr">age</span>: number;
    <span class="hljs-attr">address</span>: string;
}

<span class="hljs-comment">// 将所有属性变为可选</span>
type <span class="hljs-title class_">PartialPerson</span> = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    name?: string;</span>
<span class="hljs-comment">//    age?: number;</span>
<span class="hljs-comment">//    address?: string;</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// 将所有属性变为只读</span>
type <span class="hljs-title class_">ReadonlyPerson</span> = <span class="hljs-title class_">Readonly</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    readonly name: string;</span>
<span class="hljs-comment">//    readonly age: number;</span>
<span class="hljs-comment">//    readonly address: string;</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// 自定义映射类型</span>
type <span class="hljs-title class_">Nullable</span>&lt;T&gt; = {
    [P <span class="hljs-keyword">in</span> keyof T]: T[P] | <span class="hljs-literal">null</span>;
};

<span class="hljs-comment">// 使用自定义映射类型</span>
type <span class="hljs-title class_">NullablePerson</span> = <span class="hljs-title class_">Nullable</span>&lt;<span class="hljs-title class_">Person</span>&gt;;
<span class="hljs-comment">// 等价于:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//    name: string | null;</span>
<span class="hljs-comment">//    age: number | null;</span>
<span class="hljs-comment">//    address: string | null;</span>
<span class="hljs-comment">// }</span>
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. v-if 和 v-show 的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10 .什么是 viewport？如何在页面中设置视口大小？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 视口是用户可以看到的网页区域。设置视口的常见做法是在 <code>&lt;head&gt;</code> 中添加如下标签</li>
</ul>
<pre><code class="hljs language-html">  &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 IP 地址？它分为哪几类？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> IP 地址是互联网协议地址，是分配给网络设备的逻辑地址，用于在网络中标识设备的位置，实现设备之间的通信。IP 地址分为 IPv4 和 IPv6 两种版本，常见的 IPv4 地址分
为以下 5 类：</li>
<li><strong>1：</strong> A 类地址：范围从 0.0.0.0 到 127.255.255.255，首位为 0，主要用于大型网络。</li>
<li><strong>1：</strong> B 类地址：范围从 128.0.0.0 到 191.255.255.255，前两位为 10，用于中型网络。</li>
<li><strong>1：</strong> C 类地址：范围从 192.0.0.0 到 223.255.255.255，前三位为 110，用于小型网络。</li>
<li><strong>1：</strong> D 类地址：范围从 224.0.0.0 到 239.255.255.255，前四位为 1110，用于组播。</li>
<li><strong>1：</strong> E 类地址：范围从 240.0.0.0 到 255.255.255.255，前四位为 1111，保留为研究使用。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. Nodejs适用于哪些场景？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>T后端开发，Nodejs的异步I/O天生适合做Web高并发。</p>
</li>
<li><p>BFF开发，比如SSR中间层或者GraphQL中间层。</p>
</li>
<li><p>前端基建，Webpack、Gulp、Babel、Jest等等前端工程化的工具或插件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. React.memo 的作用和使用场景</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> 作用1： 性能优化：React.memo 是一个高阶组件，它通过对组件的 props 进行浅比较来决定组件是否需要重新渲染。如果传入组件的 props 没有发生变化，组
件就不会重新渲染；只有当 props 发生变化时，组件才会重新渲染。这有助于减少不必要的渲染操作，提高应用程序的性能。</li>
<li><strong>1：</strong> 作用2：避免重复渲染：在 React 应用中，当一个组件的父组件重新渲染时，它默认会导致子组件也重新渲染。对于那些只依赖于 props 且计算成本较高的组件，这
种默认行为可能会导致性能浪费。React.memo 可以帮助解决这个问题，它可以让组件 “记住” 之前的渲染结果，在 props 不变的情况下跳过重新渲染。</li>
<li><strong>1：</strong> 使用场景1：纯展示组件。纯展示组件是指那些只根据传入的 props 来展示 UI，没有内部状态变化和副作用（如数据获取、订阅事件等）的组件。例如，一个简单的用户
信息展示组件，它接收用户的姓名、年龄等信息作为 props，并将这些信息展示出来。示例：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserInfo</span> = (<span class="hljs-params">{ name, age }</span>) =&gt; (
    &lt;div&gt;
        &lt;p&gt;Name: {name}&lt;/p&gt;
        &lt;p&gt;Age: {age}&lt;/p&gt;
    &lt;/div&gt;
);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">UserInfo</span>);
<span class="hljs-comment">//在这个例子中，UserInfo 组件是一个纯展示组件。通过使用 React.memo 包裹它，当组件的 name 和 age props 没有变化时，组件就不会重新渲染，从而提高了性能。</span>
</code></pre><ul>
<li><strong>1：</strong> 使用场景2：大型组件树中的子组件。在大型的 React 应用中，组件树可能会非常复杂。在这种情况下，一些深层次的子组件可能会因为父组件的重新渲染而频繁地重新渲染，即
使这些子组件的 props 并没有实际变化。示例：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Sidebar</span> = (<span class="hljs-params">{ menuData }</span>) =&gt; {
    <span class="hljs-comment">// 复杂的菜单渲染逻辑</span>
    <span class="hljs-keyword">return</span> (
        &lt;div&gt;
            {menuData.map((item) =&gt; (
                &lt;MenuItem key={item.id} item={item} /&gt;
            ))}
        &lt;/div&gt;
    );
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Sidebar</span>);
<span class="hljs-comment">//通过使用 React.memo 包裹 Sidebar 组件，当父组件重新渲染但 menuData 没有变化时，Sidebar 组件就不会重新渲染，避免了不必要的渲染开销，提高了整个页面的性能。</span>
</code></pre><ul>
<li><strong>1：</strong> 使用场景3：在函数式组件中。如果组件的渲染逻辑比较复杂，或者组件在一个频繁更新的环境中（如在一个实时数据更新的仪表盘应用中），使用 React.memo 可以有效减少不
必要的渲染。示例：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">RealTimeChart</span> = (<span class="hljs-params">{ dataArray, chartType }</span>) =&gt; {
    <span class="hljs-comment">// 复杂的图表绘制逻辑，可能涉及到数据处理、坐标轴设置等</span>
    <span class="hljs-keyword">return</span> (
        &lt;div&gt;
            &lt;Chart data={dataArray} type={chartType} /&gt;
        &lt;/div&gt;
    );
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">RealTimeChart</span>);
<span class="hljs-comment">//当数据更新时，只有 dataArray 或 chartType 发生变化，RealTimeChart 组件才会重新渲染，否则将使用之前的渲染结果，避免了因其他无关因素导致的重新渲染，提升了性能。</span>
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 简述 Vuex 的核心概念和工作流程</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 核心概念:<br/>
&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>
&emsp;Mutations：用于同步修改 State 中的数据。
是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>
&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>
&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li>
<li><strong>1：</strong> 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，
Mutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化
和组件的更新。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">哪些操作会造成内存泄漏？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li><strong>1：</strong> 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li><strong>1：</strong> 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li><strong>1：</strong> 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. Pinia与 Vuex 有哪些不同？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>更符合 Composition API 思维模式</p>
<p>更好的 TypeScript 类型支持</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 说一下 Vue SSR 的实现原理</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。</p>
</li>
<li><p>SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. 什么是 mixin？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p>
</li>
<li><p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>
</li>
<li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. HTML、XML、XHTML 的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>HTML：超文本标记语言，是语法较为松散的、不严格的Web语言；</p>
</li>
<li><p>XML：可扩展标记语言，是语法较为严格、严格的标记语言；</p>
</li>
<li><p>XHTML：可扩展超文本标记语言，是HTML进行XML严格化的结果；</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. 深浅拷贝的区别？如何实现一个深拷贝？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>深浅拷贝通常只针对引用类型</p>
</li>
<li><p>浅拷贝：只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针</p>
</li>
<li><p>深拷贝：层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象 JSON.parse(JSON.stringify(obj)) --- 无法处理 undefined Symbol function -- 无法处理循环引用</p>
</li>
</ul>
<pre><code class="hljs language-js">
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
          newObj[key]=obj[key]
        }
      }
      <span class="hljs-keyword">return</span>  newObj
} 
<span class="hljs-comment">// 咱们会浅拷贝当然还要深拷贝呀  开始</span>
<span class="hljs-title class_">Function</span>  <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">obj</span>){
      <span class="hljs-keyword">let</span> newObj = {]
      <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span>  obj ){
        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key)){ 
        <span class="hljs-comment">//hasOwnProperty检测对象自己身上方法而不是原先链上的</span>
        <span class="hljs-keyword">if</span>  ( <span class="hljs-title function_">typeof</span>(obj[key])!==obj||obj[key]===<span class="hljs-literal">null</span>){
           newObj[key]=obj[key]
        }<span class="hljs-keyword">else</span>{
           newObj[key]=<span class="hljs-title function_">shallowCopy</span>(obj[key])
        }  
        }
      }
      <span class="hljs-keyword">return</span>  newObj
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">GET和POST有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>GET请求的请求参数会附加在URL之后，参数之间使用&quot;&amp;&quot;连接，多个参数将会造成URL长度增加。而POST请求的请求参数则包含在请求体中，不会在URL中显示。</li>
<li>由于GET请求的参数附加在URL之后，因此其请求长度受限于浏览器对URL长度的限制（通常浏览器对URL的长度有限制，而服务器对URL的长度限制更为宽松）。而POST请求则没有这个问题，请求参数包含在请求体中，因此可以传输大量数据。</li>
<li>GET请求的参数会暴露在URL中，因此不能用于传输敏感信息，如密码等。而POST请求的参数在请求体中，不会在URL中显示，相对更加安全。然而，这并不意味着POST请求就一定比GET请求更安全，因为安全性还需要依赖于其他因素，如SSL/TLS加密等。</li>
<li>GET请求是幂等的，即多次执行同一GET请求，服务器将返回相同的结果。而POST请求则不是幂等的，因为每次提交都会创建新的资源。</li>
<li>GET请求可以被缓存，而POST请求则不会，除非在响应头中包含适当的Cache-Control或Expires字段。</li>
<li>GET请求可以被浏览器缓存，因此可以通过点击后退按钮或刷新按钮来重复执行。而POST请求则不会，因为这些操作对POST请求没有实际意义。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是内存映射（Memory Mapping）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 内存映射指的是将外部设备或文件的数据映射到内存，使得程序可以像访问内存一样访问这些数据。这种技术可以大大加快数据访问速度，同时简化编程和数据处理。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. useState 连续调用，页面不更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [age,  setAge] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">42</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
  <span class="hljs-title function_">setAge</span>(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 + 1)</span>
}

<span class="hljs-comment">// 点击一次后，age 将只会变为 43 而不是 45！</span>
</code></pre><ul>
<li><strong>1：</strong> 连续调用 useState 不会触发页面更新，因为每次调用 useState 都会返回一个新的状态值和更新状态的函数。</li>
<li><strong>1：</strong> 要连续更新状态，你可以使用函数式更新，将当前状态作为参数传递给更新函数</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(42 =&gt; 43)</span>
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(43 =&gt; 44)</span>
  <span class="hljs-title function_">setAge</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// setAge(44 =&gt; 45)</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">20.你如何在Node.js中处理HTTP请求和响应？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>创建 HTTP 服务端程序。首先需要使用 http 模块创建一个 HTTP 服务端程序，并设置相应的回调函数.</p>
</li>
<li><p>监听 HTTP 请求事件。然后需要使用 http.createServer() 方法创建一个 HTTP 服务实例，并监听 request 事件以接收客户端发送来的 HTTP 请求。</p>
</li>
<li><p>处理 HTTP 请求。当接收到 HTTP 请求时，需要解析请求头、查询字符串以及请求体中的数据，并根据请求的方法和路径来确定具体的响应内容。</p>
</li>
<li><p>发送响应到客户端。最后需要使用 response.end() 方法将响应发送回客户端。</p>
</li>
<li><p>通过以上步骤，可以在 Node.js 中有效地处理 HTTP 请求和响应，为用户提供丰富的 Web 功能和服务。
需要注意的是，由于 Node.js 是单线程模型，因此在同一时刻只能处理一个请求。为了能够同时处理多个请求，可以通过集群、负载均衡等方式将多个请求分发到不同的 Node.js 进程中进行处理。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是主板 ？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 主板是计算机的核心部件，连接各种硬件设备。选择合适的主板对于提高计算机的稳定性和性能具有重要意义。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. 说说Ajax的原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Async Javascript and XML ，是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面。</p>
</li>
<li><p>创建XHR实例对象</p>
</li>
<li><p>调用实例对象中的open方法与服务器建立连接</p>
</li>
<li><p>调用实例对象中的send方法发送请求</p>
</li>
<li><p>监听onreadystatechange事件，通过判断readyState的值来获取到最终的数据</p>
</li>
<li><p>将数据更新到html页面</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 解释 CSS 中的 flex 布局，并列举一些常用的 flex 属性及其作用</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>
flex 布局（弹性布局）可以更方便地实现各种复杂的布局。常用属性包括：
display: flex：将容器设置为弹性容器。
flex-direction：指定主轴方向，如 row（水平，从左到右）、row-reverse（水平，从右到左）、column（垂直，从上到下）、column-reverse（垂直，从下到上）。
justify-content：在主轴上对齐项目，如 flex-start（起始位置对齐）、flex-end（末尾位置对齐）、center（居中对齐）、space-between（两端对齐，项目之间均匀分布）、space-around（每个项目两侧均匀分布）。
align-items：在交叉轴上对齐项目，类似 justify-content 有 flex-start、flex-end、center、baseline（项目第一行文字基线对齐）、stretch（默认值，拉伸项目以适应容器）等取值。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. ES6 和 CommonJS 的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const</li>
<li><strong>2：</strong> import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错</li>
</ul>
<p>注：S6 Module和CommonJS模块的共同点：</p>
<p>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变</p>
<p><a href="https://juejin.cn/post/7331931937357496354">docs</a></p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">39. 有使用过v-memo么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。</p>
<p>一般与v-for配合使用，v-memo的值是一个数组。数组的值不改变的情况，该组件及子组件就会跳过更新</p>
<p>v-memo 绑定的值没改变，子组件引用的响应数据变了，也不会更新</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</p>
<p>离线的情况下，浏览器会直接使用离线存储的资源。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">47. class的原型本质怎么理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>原型：所有的class都有显示原型，每个实例都有隐式原型，实例的隐式原型等于对应class的显示原型，非基本属性的class的隐式原型等于其继承的class的显示原型。</p>
</li>
<li><p>原型链：每一个对象都有一个隐式原型叫__proto__，它的指向是构造函数的原型对象。当查找某个属性或方法时，先从自身上查找，没有找到会沿着__proto_找到构造函数的原型对象，仍然没有找到会继续沿着__proto__向上查找到它构造函数原型对象的原型对象，直到找到顶级对象object为null，由此形成的链条为原型链。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是PCIe（Peripheral Component Interconnect Express）总线？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> PCIe是一种高速总线，常用于连接显卡、网卡、存储设备等高带宽设备。它提供了多个通道和高速数据传输，可以显著提高这些设备的性能。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释一下什么是处理器架构（CPU Architecture）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 处理器架构指的是处理器的设计模式和实现原理，比如采用的指令集架构、处理器内部的结构、对内存的访问方式等。不同的处理器架构会对编写和运行程序等方面产生影响。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">38. 怎么监听子组件内的错误？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Error&quot;</span>);

<span class="hljs-comment">//父组件</span>
<span class="hljs-keyword">import</span> { onErrorCaptured } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-comment">// 监听到子组件错误，执行回调</span>
<span class="hljs-title function_">onErrorCaptured</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Nuxt.js的SEO优化方案有哪些？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> Meta标签管理：</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">head</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">title</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>,
    <span class="hljs-attr">meta</span>: [
      { <span class="hljs-attr">hid</span>: <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">description</span> },
      { <span class="hljs-attr">hid</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">keywords</span> }
    ]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 服务端渲染(SSR)：</p>
<ul>
<li>预渲染完整HTML</li>
<li>更好的首屏加载</li>
<li>搜索引擎可直接爬取内容</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span>
}
</code></pre></li>
<li><p><strong>1：</strong> 静态站点生成(SSG)：</p>
<ul>
<li>构建时生成静态HTML</li>
<li>适合内容不常更新的站点</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;static&#x27;</span>,
  <span class="hljs-attr">generate</span>: {
    <span class="hljs-attr">routes</span>: [<span class="hljs-string">&#x27;/posts/1&#x27;</span>, <span class="hljs-string">&#x27;/posts/2&#x27;</span>]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 结构化数据：</p>
<ul>
<li>实现JSON-LD</li>
<li>添加Schema.org标记</li>
<li>提供更丰富的搜索结果</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">head</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">script</span>: [{
      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;application/ld+json&#x27;</span>,
      <span class="hljs-attr">json</span>: {
        <span class="hljs-string">&quot;@context&quot;</span>: <span class="hljs-string">&quot;https://schema.org&quot;</span>,
        <span class="hljs-string">&quot;@type&quot;</span>: <span class="hljs-string">&quot;Article&quot;</span>,
        <span class="hljs-string">&quot;headline&quot;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>
      }
    }]
  }
}
</code></pre></li>
<li><p><strong>1：</strong> 性能优化：</p>
<ul>
<li>图片懒加载</li>
<li>资源预加载</li>
<li>代码分割</li>
<li>缓存策略</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">render</span>: {
    <span class="hljs-attr">http2</span>: {
      <span class="hljs-attr">push</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">static</span>: {
      <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>
    }
  }
}
</code></pre></li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-20T07:48:59.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"CTkw0PK5\",\"ing.md\":\"DL86CGT1\",\"readme.md\":\"DpzICQXC\",\"src_guide_getting-started.md\":\"BnajlPee\",\"src_guide_why.md\":\"8tLeH9Kg\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DP6_ZZTd\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"S1cIfKIU\",\"src_questions_computer-base_1_计算机硬件.md\":\"D-Tb3IPy\",\"src_questions_computer-base_2_计算机软件.md\":\"NyGPLh_L\",\"src_questions_computer-base_3_计算机网络.md\":\"CO8XU_g9\",\"src_questions_computer-base_4_计算机编程.md\":\"De3mqJbw\",\"src_questions_computer-base_5_计算机科学.md\":\"DjPmnEMd\",\"src_questions_computer-base_6_软件工程.md\":\"BXzX9ltk\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"ve7-2AgW\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"CrIjb5im\",\"src_questions_data-structures-algorithms_1_算法.md\":\"-YgfpHts\",\"src_questions_front-architect_1_前端架构.md\":\"CF4fLZzv\",\"src_questions_front-base_1_html.md\":\"sshGoi4C\",\"src_questions_front-base_2_css.md\":\"T4ZeMKcu\",\"src_questions_front-base_3_javascript.md\":\"CqZUsD6V\",\"src_questions_front-base_4_typescript.md\":\"DferFB1f\",\"src_questions_front-component_1_ui组件库.md\":\"DO-heINN\",\"src_questions_front-component_2_业务组件库.md\":\"CIZmyoNW\",\"src_questions_front-engineering_1_前端标准化.md\":\"DOwqYDlX\",\"src_questions_front-engineering_2_前端自动化.md\":\"V5-Zc-xk\",\"src_questions_front-engineering_3_webpack.md\":\"CGPAgr9t\",\"src_questions_front-engineering_4_vite.md\":\"DXgs0AiU\",\"src_questions_front-engineering_5_rollup.md\":\"Jj-9Uz73\",\"src_questions_front-frame_1_react.md\":\"DPecbFzf\",\"src_questions_front-frame_2_vue.md\":\"DsA0Yia-\",\"src_questions_front-frame_3_next.md\":\"B9MoxSWf\",\"src_questions_front-frame_4_nuxt.md\":\"BkjcVALy\",\"src_questions_front-frame_5_qiankun.md\":\"D-fDe6z_\",\"src_questions_front-newest_1_前端最前沿.md\":\"B9U0aoDU\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"Co-7xS07\",\"src_questions_front-runtime_1_浏览器.md\":\"D2lQaMVV\",\"src_questions_front-runtime_2_nodejs.md\":\"CZKI2jly\",\"src_questions_front-safety_1_前端安全.md\":\"BQ75S_La\",\"src_questions_server_1_nest.md\":\"Bi7nF5eA\",\"src_questions_server_2_mongodb.md\":\"7FYNHmf5\",\"src_questions_server_3_mysql.md\":\"vuzC1sWV\",\"src_questions_server_4_nginx.md\":\"BRDTRtUY\",\"src_questions_server_5_docker.md\":\"D9jqJ5bA\",\"src_questions_server_6_kubernets.md\":\"V1Aa_pdO\",\"src_questions_server_7_nacos.md\":\"CG-17Jee\",\"src_questions_server_8_redis.md\":\"-0h5jPEb\",\"src_training_training-architecture_index.md\":\"WLLVecgj\",\"src_training_training-experts_index.md\":\"BYfpfL7U\",\"src_training_training-intermediate_index.md\":\"T9Bl1nHb\",\"src_training_training-primary_index.md\":\"CAZxxJZr\",\"src_training_training-senior_index.md\":\"DQslWmgK\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>