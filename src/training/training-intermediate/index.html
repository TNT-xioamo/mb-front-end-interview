<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.CfdlugHt.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.UPCtyyuv.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.CjDcszOu.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.5WXdMwYP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.CKJppIQ_.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-intermediate_index.md.ChiNoBY9.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-intermediate_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. src 与 href 的区别</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> <code>src</code>属性是资源路径，引入资源，属于当前页不可缺少的部分，如：<code>src=&quot;http://www.baidu.com/logo.png&quot;</code>；<code>href</code>属性是超链接，引用资源，表示该资源与当前页有关联，如：<code>href=&quot;http://www.baidu.com&quot;</code>。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. new 操作符的实现原理</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>2：</strong> new操作符的执行过程：</li>
</ul>
<blockquote>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);
  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">// 判断参数是否是一个函数</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span>
  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span>
  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);
  <span class="hljs-comment">// 判断返回对象</span>
  <span class="hljs-keyword">let</span> flag = result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);
  <span class="hljs-comment">// 判断返回结果</span>
  <span class="hljs-keyword">return</span> flag ? result : newObject;
}
<span class="hljs-comment">// 使用方法</span>
<span class="hljs-title function_">objectFactory</span>(构造函数, 初始化参数);
</code></pre></details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">TCP 三次握手与四次挥手</h4><div class="head-re"><span class="head-score">7 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>TCP 三次握手</li>
<li><strong>1：</strong> 第一次握手：客户端发送一个 SYN（同步）报文段，其中包含客户端的初始序列号seq=x，表示客户端请求建立连接。</li>
<li><strong>1：</strong> 第二次握手：服务器收到客户端的 SYN 报文段后，发送一个 SYN+ACK 报文段，其中ack=x+1表示对客户端序列号的确认，seq=y是服务器的初始序列号，表示服
务器同意建立连接。</li>
<li><strong>1：</strong> 第三次握手：客户端收到服务器的 SYN+ACK 报文段后，发送一个 ACK 报文段，其中ack=y+1表示对服务器序列号的确认，seq=x+1，表示客户端连接建立成
功。此时，双方都确认连接已建立，可以开始数据传输。</li>
<li>TCP 四次挥手</li>
<li><strong>1：</strong> 第一次挥手：主动关闭方（假设为客户端）发送一个 FIN（结束）报文段，其中seq=u，表示客户端请求关闭连接。</li>
<li><strong>1：</strong> 第二次挥手：服务器收到客户端的 FIN 报文段后，发送一个 ACK 报文段，其中ack=u+1，seq=v，表示服务器确认收到客户端的关闭请求，但服务器可能还有数据
未发送完，所以先不关闭连接。</li>
<li><strong>1：</strong> 第三次挥手：当服务器数据发送完后，发送一个 FIN 报文段，其中seq=w，ack=u+1，表示服务器请求关闭连接。</li>
<li><strong>1：</strong> 第四次挥手：客户端收到服务器的 FIN 报文段后，发送一个 ACK 报文段，其中ack=w+1，seq=u+1，表示客户端确认收到服务器的关闭请求，此时客户端等待一段
时间（2MSL）后关闭连接，服务器收到 ACK 报文段后也关闭连接。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. 简述 Vuex 的核心概念和工作流程</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 核心概念:<br/>
&emsp;State：存储应用的状态数据，是一个单一的数据源，所有组件都可以访问, <br/>
&emsp;Mutations：用于同步修改 State 中的数据。
是唯一允许修改 State 的地方，它接收 State 作为第一个参数。<br>
&emsp;Actions：用于处理异步操作，如异步数据获取等，它不能直接修改 State，而是通过提交 Mutations 来间接修改。<br/>
&emsp;Getters(类似于计算属性，用于从 State 中派生出一些新的数据，方便组件获取和使用)</li>
<li><strong>1：</strong> 工作流程：<br/>组件通过 dispatch 方法触发 Actions，Actions 中可以进行异步操作，然后通过 commit 提交 Mutations，
Mutations 同步修改 State 的数据，组件可以通过 mapState、mapGetters 等辅助函数获取 State 和 Getters 中的数据，从而实现数据的响应式变化
和组件的更新。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">41. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>结构，样式和行为分离</p>
<p>若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。
在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。
在分离的基础上，我们需要做到代码的：精简， 重用， 有序。</p>
<p>分离的好处:</p>
<p>代码分离，利于团队的开发和后期的维护；</p>
<p>减少维护成本，提高可读性和更好的兼容性；</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是DMA（Direct Memory Access）？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> DMA是一种计算机I/O技术，可以在不经过CPU干预的情况下将数据从外部设备（如硬盘）复制到内存，或者从内存传输到设备。使用DMA可以减少CPU的中断处理负担，提高数据传输速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">68. Vue 3 中的 provide 和 inject 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>provide 和 inject 用于跨层级组件通信。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { provide, ref } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello from parent&#x27;</span>);
    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;message&#x27;</span>, message); <span class="hljs-comment">// 提供数据</span>
  }
};

<span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">import</span> { inject } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;message&#x27;</span>); <span class="hljs-comment">// 注入数据</span>
    <span class="hljs-keyword">return</span> { message };
  }
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. TypeScript 如何设计 Class 的声明？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> {
   <span class="hljs-attr">greeting</span>: string;
   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: string</span>) {
       <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;
   }
   <span class="hljs-title function_">greet</span>(): string{
       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;
   }
}
<span class="hljs-keyword">let</span> greeter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>(<span class="hljs-string">&quot;world&quot;</span>);
</code></pre><ul>
<li><strong>2：</strong> Result类型是 string | number 。因为NonNullable会排除null和undefined 。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">76. EventBus 与 mitt 区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vue2 中我们使用 EventBus 来实现跨组件之间的一些通信，它依赖于 Vue 自带的$on/$emit/$off等方法，这种方式使用非常简单方便，但如果使用不当也会带来难以维护的毁灭灾难。而 Vue3 中移除了这些相关方法，这意味着 EventBus 这种方式我们使用不了，Vue3 推荐尽可能使用props/emits、provide/inject、Vuex 等其他方式来替代。</p>
<p>如果 Vue3 内部的方式无法满足，官方建议使用一些外部的辅助库，例如：mitt。优点：</p>
<p>非常小，压缩后仅有 200 bytes。</p>
<p>完整 TS 支持，源码由 TS 编码。</p>
<p>跨框架，它并不是只能用在 Vue 中，React、JQ 等框架中也可以使用。</p>
<p>使用简单，仅有 on、emit、off 等少量实用API。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. Vue 组件的 data 为什么必须是函数？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">31. 说一下 watch 与 computed 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>都是观察数据变化的（相同）</p>
</li>
<li><p>计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化</p>
</li>
<li><p>computed 有缓存，它依赖的值变了才会重新计算，watch 没有；</p>
</li>
<li><p>watch 支持异步，computed 不支持；</p>
</li>
<li><p>watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）</p>
</li>
<li><p>watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；</p>
</li>
<li><p>omputed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">CSRF 攻击</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>:1</strong> CSRF（Cross Site Request Forgery，跨站请求伪造），即在别的站点伪造了一个请求，在受害者访问一个网站时，其 cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</li>
<li><strong>:4</strong> 防御：</li>
</ul>
<blockquote>
<p>1、验证 HTTP 的 Referer 字段。<br>2、在请求地址中添加 token 并验证。<br>3、在 HTTP 头中自定义属性并验证。<br>4、涉及到数据修改操作严格使用 post 请求而不是 get 请求。  </p>
<blockquote>
<p>get 的 URL 会被放在浏览器历史和 WEB 服务器日志里面，如果把关键数据放在 get 里面，被人偷窥了浏览器，会造成数据泄露。而 post 日志没有记录，也不会保留 URL，只要数据库服务器不被入侵，基本还是安全的。</p>
</blockquote>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. Nodejs的进程管理有哪些方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Node.js的进程管理有以下几种方法：</p>
<ul>
<li><p>使用<code>child_process</code>模块创建子进程，并使用<code>process</code>模块进行进程间通信。</p>
</li>
<li><p>使用<code>cluster</code>模块创建集群，利用多核CPU资源。</p>
</li>
<li><p>使用<code>pm2</code>等第三方进程管理工具，如自动重启、负载均衡、日志管理等功能。</p>
</li>
<li><p>使用<code>forever</code>等第三方工具，如自动重启、日志管理等功能。</p>
</li>
<li><p>使用<code>node-mac</code>等第三方工具，如自动重启、日志管理等功能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. Nodejs的文件系统有哪些方法？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Node.js的文件系统有以下几种方法：</p>
<ul>
<li><p><code>fs.readFile</code>：读取文件内容。</p>
</li>
<li><p><code>fs.writeFile</code>：写入文件内容。</p>
</li>
<li><p><code>fs.appendFile</code>：追加文件内容。</p>
</li>
<li><p><code>fs.unlink</code>：删除文件。</p>
</li>
<li><p><code>fs.rename</code>：重命名文件。</p>
</li>
<li><p><code>fs.stat</code>：获取文件信息。</p>
</li>
<li><p><code>fs.readdir</code>：读取目录内容。</p>
</li>
<li><p><code>fs.mkdir</code>：创建目录。</p>
</li>
<li><p><code>fs.rmdir</code>：删除目录。</p>
</li>
<li><p><code>fs.watch</code>：监听文件或目录的变化。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. 什么是函数组件和类组件？它们有什么区别？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>函数组件：</p>
</li>
<li><p>定义：函数组件是一个简单的 JavaScript 函数，接收 props 作为参数，返回 JSX。</p>
</li>
<li><p>优点：代码更简洁，性能更好（因为没有类的开销）。</p>
</li>
<li><p>限制：早期版本的函数组件不支持生命周期方法和状态管理，但随着 Hooks 的引入，这些限制已经被解除。</p>
</li>
<li><p>类组件：</p>
</li>
<li><p>定义：类组件是继承自 React.Component 的 ES6 类，可以定义生命周期方法和管理状态。</p>
</li>
<li><p>优点：支持生命周期方法和状态管理，功能更强大。</p>
</li>
<li><p>缺点：代码相对复杂，性能略逊于函数组件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">53. Vuex和单纯的全局对象有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">71. Vue 3 中的 Fragment 是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Fragment 允许组件返回多个根元素。</p>
<pre><code class="hljs language-js">
&lt;template&gt;
  &lt;div&gt;Hello&lt;/div&gt;
  &lt;div&gt;Vue 3&lt;/div&gt;
&lt;/template&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">nuxt2和nuxt3的区别</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> 性能方面：<br/>
&emsp;Nuxt3：性能有显著提升。它采用了 Vite 作为默认的开发服务器和构建工具（也支持 Webpack）。Vite 利用了现代浏览器的原生 ES 模块支持，
在开发阶段可以实现更快的冷启动和热更新。例如，当修改一个组件文件时，Nuxt3 + Vite 能够几乎即时地更新页面，而不需要像 <br/>
&emsp;Nuxt2（基于 Webpack）那样进行较长时间的重新打包过程。在构建产物方面，Nuxt3 也能够生成更优化的代码，减少不必要的资源加载，从而提升页面加载速度。
Nuxt2：基于 Webpack 构建，在开发过程中，热更新速度相对较慢。每次更新代码后，Webpack 需要重新构建模块图，这可能导致几秒钟的延迟。在构建用于生产环境的项目时，
生成的代码包可能会包含一些冗余代码，影响最终的性能。</li>
<li><strong>1：</strong> 目录结构和文件约定：<br/>
&emsp;Nuxt3：目录结构更加灵活。它仍然支持传统的pages目录用于定义路由页面，但是引入了新的composables目录用于存放可组合函数，这些函数可以在多个组件之间共享逻辑。
例如，你可以在composables目录下创建一个useAuth.js文件，用于处理用户认证逻辑，然后在多个组件中使用这个函数。同时，Nuxt3 对layouts目录的使用也更加灵活，
允许更好地定制页面布局。<br/>
&emsp;Nuxt2：有比较固定的目录结构，pages目录下的文件直接对应路由，layouts目录主要用于定义页面布局模板，这种结构相对简单直接，但在复杂项目中灵活性稍差。
例如，在 Nuxt2 中，如果你想共享一些非路由相关的逻辑，可能需要通过插件或者在store（如果使用 Vuex）中实现，没有像 Nuxt3 的composables这样专门的目录。</li>
<li><strong>1：</strong> TypeScript 支持：<br/>
&emsp;Nuxt3：对 TypeScript 有更好的原生支持。整个框架的核心代码和 API 都是用 TypeScript 编写的，这使得在开发过程中能够提供更好的类型检查和自动补全功能。
例如，在定义组件的props时，TypeScript 能够准确地检查传入属性的类型是否正确，减少运行时错误。并且 Nuxt3 在很多配置文件和插件开发中也更方便地使用 TypeScript，
开发体验更加友好。<br/>
&emsp;Nuxt2：虽然也可以使用 TypeScript，但需要额外的配置和一些复杂的步骤来实现较好的类型支持。例如，在 Nuxt2 中使用 TypeScript 编写组件时，可能需要手动安
装和配置相关的 Babel 插件来处理类型转换，并且在一些插件开发和与 Vuex（如果使用）结合时，TypeScript 的集成度没有 Nuxt3 高。</li>
<li><strong>1：</strong> Composition API 和 Options API：<br/>
&emsp;Nuxt3：更加强调使用 Composition API。它提供了一系列的组合式函数，如useFetch用于数据获取，useState用于状态管理等。这些函数使得组件逻辑更加清晰，可
复用性更强。例如，useFetch可以在组件中轻松地获取数据，并且可以在多个组件中复用这个数据获取逻辑，而不需要像 Nuxt2 那样可能更多地依赖于 Options API 中
的mounted等生命周期钩子来实现相同的功能。<br/>
&emsp;Nuxt2：主要使用 Options API，通过data、methods、mounted等选项来定义组件。虽然也可以使用 Composition API，但没有 Nuxt3 那么自然和方便。
例如，在 Nuxt2 中使用 Composition API 可能需要额外引入 Vue 3 的相关 API，并且在与 Nuxt2 的生态（如插件、模块）结合时可能会遇到一些兼容性问题。</li>
<li><strong>2：</strong> Server - side Rendering (SSR) 和 Static Site Generation (SSG)：<br/>
&emsp;Nuxt3：在 SSR 和 SSG 方面有一些改进。它提供了更灵活的生成策略，例如在 SSG 中可以更好地控制预渲染的页面和数据获取方式。对于动态路由的 SSG，Nuxt3 能
够根据不同的参数更高效地生成页面。在 SSR 模式下，Nuxt3 也优化了服务器端渲染的性能和资源利用。<br/>
&emsp;Nuxt2：支持 SSR 和 SSG，但在一些复杂的场景下，如动态路由的预渲染和数据获取策略上相对 Nuxt3 不够灵活。例如，在 Nuxt2 中处理动态路由的 SSG 可能需要
更多的手动配置和复杂的逻辑来确保数据的正确获取和页面的预渲染。</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">61. v-if 和 v-show 的区别是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>v-if 是真正的条件渲染，它会根据表达式的真假值来决定是否将元素添加到 DOM 中；而 v-show 则始终会渲染元素，只是通过 CSS 样式控制其可见性。因此，当条件频繁切换时，v-show 更高效，因为它避免了销毁和重建元素的过程。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. React 中的 Hook 是什么？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> useState()：用于在函数组件中添加状态。</li>
<li><strong>1：</strong> useEffect()：用于在函数组件中执行副作用操作（如数据请求、订阅、DOM 操作等）。</li>
<li><strong>1：</strong> useContext()：用于在函数组件中访问上下文（Context）。</li>
<li><strong>1：</strong> useReducer()：类似于 useState，但适用于复杂的状态管理，类似于 Redux 的 reducer。</li>
<li><strong>1：</strong> useRef()：用于访问组件中的 DOM 节点或保存可变的值。</li>
<li><strong>1：</strong> useMemo() 和 useCallback()：用于性能优化，避免不必要的渲染。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">36. React的事件和普通的HTML事件有什么不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>区别：</p>
<ul>
<li><p>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</p>
</li>
<li><p>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</p>
</li>
<li><p>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>
</li>
</ul>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>
<ul>
<li><p>兼容所有浏览器，更好的跨平台；</p>
</li>
<li><p>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</p>
</li>
<li><p>方便 react 统一管理和事务机制。</p>
</li>
</ul>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. 使用 Mobx 的特点是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Mobx 提供了类似observable和的装饰器computed来定义可观察的状态和反应函数。用action修饰的动作用于修改状态，确保跟踪所有更改。Mobx 还提供自动依赖跟踪、不同类型的反应、对反应性的细粒度控制，以及通过 mobx-react 包与 React 无缝集成。总体而言，Mobx 通过根据可观察状态的变化自动执行更新过程来简化状态管理。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">62. 创建自定义钩子的规则是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>钩子名称以 &quot;use &quot;开头。</p>
</li>
<li><p>钩子只能从其他钩子或 React 元素中调用。</p>
</li>
<li><p>不要有条件地调用钩子。</p>
</li>
<li><p>将可重复使用的逻辑提取到自定义钩子中。</p>
</li>
<li><p>自定义钩子必须是纯函数。</p>
</li>
<li><p>自定义钩子可以返回值或其他钩子。</p>
</li>
<li><p>以描述性的方式命名自定义钩子。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">43. React如何判断什么时候重新渲染组件？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。</p>
<p>当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是PWA？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 渐进式网络应用（PWA）是谷歌在2015年底提出的概念。基本上算是web应用程序，但在外观和感觉上与原生app类似。支持PWA的网站可以提供脱机工作、推送通知和设备硬件访问等功能。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">77. 在 Reducer文件里，对于返回的结果，要注意哪些问题？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在 Reducer文件里，对于返回的结果，必须要使用 Object.assign ( )来复制一份新的 state，否则页面不会跟着数据刷新。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>. <span class="hljs-title function_">assign</span> ( { }， state, {
<span class="hljs-attr">type</span>:action .<span class="hljs-property">type</span>,
shouldNotPaint : <span class="hljs-literal">true</span>
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">55. Redux 实现了哪种模式？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Redux 实现了Flux 模式，它是应用程序的可预测状态管理模式。它通过引入单向数据流和应用程序状态的集中存储来帮助管理应用程序的状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">51. 在React中组件的this.state和setState有什么区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 说说对高阶组件（HOC）的理解？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>高阶函数（Higher-order function），至少满足下列一个条件的函数</p>
</li>
<li><p>接受一个或多个函数作为输入</p>
</li>
<li><p>输出一个函数</p>
</li>
<li><p>在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. react如何做到和vue中keep-alive的缓存效果</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">TCP与UDP区别是什么</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</li>
<li><strong>1：</strong> UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</li>
<li><strong>1：</strong> TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；</li>
<li><strong>1：</strong> UDP通信类似于学校广播，靠着广播播报直接进行通信。</li>
<li><strong>1：</strong> TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li><strong>1：</strong> TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li><strong>1：</strong> TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li><strong>1：</strong> UDP 的主机不需要维持复杂的连接状态表</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">57. Redux和Mobx有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。</p>
</li>
<li><p>Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">二分查找</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 适用条件： 数组必须是有序的。</li>
<li><strong>1：</strong> 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。</li>
<li><strong>1：</strong> 时间复杂度： O(log n)。</li>
<li><strong>1：</strong> 思路：<ul>
<li>每次取中间元素与目标值比较。</li>
<li>若中间值大于目标值，目标值一定在左半部分。</li>
<li>若中间值小于目标值，目标值一定在右半部分。</li>
<li>重复上述步骤直到找到目标值或数组为空。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span> (arr[mid] === target) {
        <span class="hljs-keyword">return</span> mid;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
        left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
    }
  }
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标值</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">30. React如何进行代码拆分？拆分的原则是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>react 的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>
</li>
<li><p>在我们的react项目中：</p>
</li>
<li><p>在 api 层面我们单独封装，对外暴露 http 请求的结果。</p>
</li>
<li><p>数据层我们使用的 mobx 封装处理异步请求和业务逻辑处理。</p>
</li>
<li><p>视图层，尽量使用 mobx 层面的传递过来的数据，修改逻辑。</p>
</li>
<li><p>静态类型的资源单独放置</p>
</li>
<li><p>公共组件、高阶组件、插件单独放置</p>
</li>
<li><p>工具类文件单独放置</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">40. React.createClass和extends Component的区别有哪些？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>语法区别</p>
<ul>
<li><p>createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。</p>
</li>
<li><p>createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p>
</li>
</ul>
<p>propType 和 getDefaultProps</p>
<ul>
<li><p>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</p>
</li>
<li><p>React.Component：通过设置两个属性propTypes和defaultProps</p>
</li>
</ul>
<p>状态的区别</p>
<ul>
<li><p>React.createClass：通过getInitialState()方法返回一个包含初始值的对象</p>
</li>
<li><p>React.Component：通过constructor构造函数设置初始状态</p>
</li>
</ul>
<p>this.state</p>
<ul>
<li><p>React.createClass：需要显示的调用this.setState()方法</p>
</li>
<li><p>React.Component：不需要调用，直接this.state获取</p>
</li>
</ul>
<p>Mixins</p>
<ul>
<li><p>React.createClass：通过mixins属性混合进来</p>
</li>
<li><p>React.Component：通过引入React Mixin</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">78. 什么是 Redux Thunk？它解决了什么问题？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>Redux Thunk 是一个中间件，允许你在 action 创建函数中返回一个函数而不是一个 action 对象。这个返回的函数可以包含异步逻辑，并在适当的时候 dispatch 一个或多个 action。</p>
<p>解决问题：</p>
<p>异步操作：Redux Thunk 允许你处理异步操作，如 AJAX 请求，而不需要在 reducer 中处理异步逻辑。</p>
<p>复杂逻辑：可以处理复杂的业务逻辑，如条件 dispatch、多次 dispatch 等。</p>
<pre><code class="hljs language-js">
<span class="hljs-keyword">import</span> { createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>;

<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span> };

<span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> = (<span class="hljs-params">state = initialState, action</span>) =&gt; {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">data</span>: action.<span class="hljs-property">payload</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">async</span> (dispatch) =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FETCH_DATA_SUCCESS&#x27;</span>, <span class="hljs-attr">payload</span>: data });
};

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, <span class="hljs-title function_">applyMiddleware</span>(thunk));

store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">fetchData</span>());
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. React中的setState和replaceState的区别是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>（1）setState() setState()用于设置状态对象，其语法如下：</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会和当前的state合并</p>
</li>
<li><p>callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值</p>
</li>
</ul>
<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p>
<p>（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">replaceState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会替换当前的state。</p>
</li>
<li><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>
</li>
</ul>
<p>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">45. 对 React-Intl 的理解，它的工作原理？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。</p>
<p>React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。</p>
<p>在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 说说对Fiber架构的理解？解决了什么问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>在react中，主要做了以下的操作：</p>
<ul>
<li><strong>1：</strong> 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li><strong>1：</strong> 增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li><strong>1：</strong> dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
<li><strong>1：</strong> Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-20T07:51:19.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"I2qm1XX_\",\"ing.md\":\"Bb0ZqJ7c\",\"readme.md\":\"Z85FzMig\",\"src_guide_getting-started.md\":\"CgewSSIj\",\"src_guide_why.md\":\"B9kqR_JE\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"DFk6nmNt\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"BdfGvteE\",\"src_questions_computer-base_1_计算机硬件.md\":\"Cux7f22v\",\"src_questions_computer-base_2_计算机软件.md\":\"BrzuwvT7\",\"src_questions_computer-base_3_计算机网络.md\":\"CWxjXj3d\",\"src_questions_computer-base_4_计算机编程.md\":\"DOSrDS2h\",\"src_questions_computer-base_5_计算机科学.md\":\"CY1q6ewh\",\"src_questions_computer-base_6_软件工程.md\":\"NjbhjQm6\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"Rz3_e8WZ\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"DF0Vw-xZ\",\"src_questions_data-structures-algorithms_1_算法.md\":\"CI-l_iZZ\",\"src_questions_front-architect_1_前端架构.md\":\"wooZqFbS\",\"src_questions_front-base_1_html.md\":\"CQFkGQhn\",\"src_questions_front-base_2_css.md\":\"2zPQ0LT4\",\"src_questions_front-base_3_javascript.md\":\"CXOpicK3\",\"src_questions_front-base_4_typescript.md\":\"PP3mUTo9\",\"src_questions_front-component_1_ui组件库.md\":\"BVasNK3Y\",\"src_questions_front-component_2_业务组件库.md\":\"CDhRllX8\",\"src_questions_front-engineering_1_前端标准化.md\":\"gbZAj7MS\",\"src_questions_front-engineering_2_前端自动化.md\":\"D0LTnKhV\",\"src_questions_front-engineering_3_webpack.md\":\"Ds5ntTXw\",\"src_questions_front-engineering_4_vite.md\":\"f0MR1TSI\",\"src_questions_front-engineering_5_rollup.md\":\"DZUC4cPy\",\"src_questions_front-frame_1_react.md\":\"BDDs4-o9\",\"src_questions_front-frame_2_vue.md\":\"DGxXswnQ\",\"src_questions_front-frame_3_next.md\":\"3gAjpE7M\",\"src_questions_front-frame_4_nuxt.md\":\"Cc-5M0Pf\",\"src_questions_front-frame_5_qiankun.md\":\"DvDzFyq3\",\"src_questions_front-newest_1_前端最前沿.md\":\"CSGAR9Oq\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DM6ZMECe\",\"src_questions_front-runtime_1_浏览器.md\":\"fmrD7owO\",\"src_questions_front-runtime_2_nodejs.md\":\"D3oRpynr\",\"src_questions_front-safety_1_前端安全.md\":\"CBSHDC3y\",\"src_questions_server_1_nest.md\":\"D1sMl8iY\",\"src_questions_server_2_mongodb.md\":\"yXRi4H1Y\",\"src_questions_server_3_mysql.md\":\"DkkVQ_w7\",\"src_questions_server_4_nginx.md\":\"CuIvoYQM\",\"src_questions_server_5_docker.md\":\"ByhUe3nK\",\"src_questions_server_6_kubernets.md\":\"CK6V1gAU\",\"src_questions_server_7_nacos.md\":\"BqxZEvXn\",\"src_questions_server_8_redis.md\":\"CRgb96oh\",\"src_training_training-architecture_index.md\":\"BYWdt_8O\",\"src_training_training-experts_index.md\":\"CBMXznxA\",\"src_training_training-intermediate_index.md\":\"ChiNoBY9\",\"src_training_training-primary_index.md\":\"BgkInPGL\",\"src_training_training-senior_index.md\":\"XFgPWiBj\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>