<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.BugVFdDY.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.BmG-BNgX.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.CKga_Nsj.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.BZMTKtii.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/componentMarkdown.C22IKpcs.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-architecture_index.md.CiiOByY3.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-architecture_" data-v-e6f2a212><div><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释数据库事务的 ACID 特性</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li>
<li><strong>1：</strong> 一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏。例如，在一个订单系统中，订单总金额必须等于所有商品金额之和，当对订单进行修改
时，事务要确保这个一致性始终成立。</li>
<li><strong>1：</strong> 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同的隔离级别（如读未提交、读已提交、可重复读、串行化）决定了事务之
间的隔离程度。例如，在可重复读隔离级别下，一个事务在两次读取同一数据时，即使期间有其他事务对该数据进行了修改，第一次读取的数据依然不变，避免了不可重复读问题。</li>
<li><strong>1：</strong> 持久性（Durability）：一旦事务提交，它对数据库的修改就应该永久保存下来。即使系统崩溃或出现其他故障，已提交的事务也不会丢失。例如，用户提交了一个订
单，即使在保存订单数据后系统马上崩溃，当系统恢复后，该订单数据依然存在。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">34. 手写发布订阅 （行为模式）</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {
  caches = {}; <span class="hljs-comment">// 事件中心</span>
  
  <span class="hljs-comment">// eventName事件名-独一无二, fn订阅后执行的自定义行为</span>
  <span class="hljs-title function_">on</span> (eventName, fn){ 
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName] || [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName].<span class="hljs-title function_">push</span>(fn);
  }
  
  <span class="hljs-comment">// 发布 =&gt; 将订阅的事件进行统一执行</span>
  <span class="hljs-title function_">emit</span> (eventName, data) { 
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName]) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName]
      .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(data));
    }
  }
  <span class="hljs-comment">// 取消订阅 =&gt; 若fn不传, 直接取消该事件所有订阅信息</span>
  <span class="hljs-title function_">off</span> (eventName, fn) { 
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName]) {
      <span class="hljs-keyword">const</span> newCaches = fn 
        ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e !== fn) 
        : [];
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">caches</span>[eventName] = newCaches;
    }
  }
​
}

    ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>();
    ​
    l1 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`l1_<span class="hljs-subst">${data}</span>`</span>)
    l2 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`l2_<span class="hljs-subst">${data}</span>`</span>)
    ​
    ob.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event1&#x27;</span>,l1)
    ob.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event1&#x27;</span>,l2)
    ​
    <span class="hljs-comment">//发布订阅</span>
    ob.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event1&#x27;</span>,<span class="hljs-number">789</span>) 
    <span class="hljs-comment">// l1_789</span>
    <span class="hljs-comment">// l2_789</span>
    ​
    <span class="hljs-comment">// 取消，订阅l1</span>
    ob.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;event1&#x27;</span>,l1)
    ​
    ob.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event1&#x27;</span>,<span class="hljs-number">567</span>)
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">1. 什么是静态网页？什么是动态网页？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 静态网页：没有与服务端发生交互的网页；动态网页：与服务端有交互的网页</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">43. Html5中datalist是什么</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。</p>
<p>datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。</p>
<pre><code class="hljs language-html">&lt;input id=<span class="hljs-string">&quot;fruits&quot;</span> list=<span class="hljs-string">&quot;fruit&quot;</span> /&gt;&lt;datalist id=&quot;fruit&quot;&gt;  &lt;option value=&quot;apple&quot;&gt;  &lt;option value=&quot;orange&quot;&gt;  &lt;option value=&quot;banana&quot;&gt;&lt;/datalist&gt;
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">60. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">12. React中的Refs是什么？有哪些使用场景？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 创建和使用Refs：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">focusInput</span> = (<span class="hljs-params"></span>) =&gt; {
    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();
  };

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;input ref={inputRef} type=&quot;text&quot; /&gt;
      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre><ul>
<li><strong>1：</strong> 转发Refs：</li>
</ul>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">FancyButton</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (
  &lt;button ref={ref} className=&quot;fancy-button&quot;&gt;
    {props.children}
  &lt;/button&gt;
));
</code></pre><ul>
<li><p><strong>1：</strong> 常见使用场景：</p>
<ul>
<li>管理焦点、文本选择或媒体播放</li>
<li>触发强制动画</li>
<li>集成第三方DOM库</li>
</ul>
</li>
<li><p><strong>1：</strong> 使用注意事项：</p>
<ul>
<li>避免过度使用Refs</li>
<li>不要用Refs来做可以通过声明式实现的事情</li>
<li>在类组件中使用需要通过React.createRef()创建</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">56. document.write() 和 innerHTML 的区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>document.write()是直接写入到页面的内容流，如果在写之前没有调用document.open()，浏览器会自动调用open()，每次写完关闭之后会重新调用该函数，会导致页面被重写；</p>
</li>
<li><p>innerHTML则是 DOM 页面元素的一个属性，代表该元素的html内容；</p>
</li>
<li><p>innerHTML将内容写入到某个DOM节点，不会导致页面重绘；</p>
</li>
<li><p>innerHTML在很多情况下都优于document.write()，原因在于其允许更精确的控制要刷新页面的那个部分</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">74. Pinia与 Vuex 有哪些不同？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>更符合 Composition API 思维模式</p>
<p>更好的 TypeScript 类型支持</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">64. 为什么会有BigInt的提案？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">浏览器的渲染过程</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li><strong>1：</strong> 然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li><strong>1：</strong> 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li><strong>1：</strong> 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li><strong>1：</strong> 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">二分查找</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 适用条件： 数组必须是有序的。</li>
<li><strong>1：</strong> 应用场景： 查找有序数组中的元素，例如数据查询、搜索问题。</li>
<li><strong>1：</strong> 时间复杂度： O(log n)。</li>
<li><strong>1：</strong> 思路：<ul>
<li>每次取中间元素与目标值比较。</li>
<li>若中间值大于目标值，目标值一定在左半部分。</li>
<li>若中间值小于目标值，目标值一定在右半部分。</li>
<li>重复上述步骤直到找到目标值或数组为空。</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">arr, target</span>) {
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span> (arr[mid] === target) {
        <span class="hljs-keyword">return</span> mid;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
        left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
    }
  }
  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标值</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">35. Redux 有哪些优点？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。</p>
</li>
<li><p>可维护性 - 由于没有直接接触 DOM，React 组件更容易进行单元测试和重用。</p>
</li>
<li><p>服务端渲染 - 你只需渲染应用一次，然后将结果发送到客户端。这对于 SEO 和快速首次渲染非常重要。</p>
</li>
<li><p>开发人员工具 - 从组件层次结构、当前状态和派生数据（如路由）到与时间旅行和编辑动作相关的任何内容，您都可以立即访问。</p>
</li>
<li><p>社区和生态系统 - React 拥有非常庞大且快速增长的生态系统，大量可重用的库和组件都可用于 React。</p>
</li>
<li><p>易于测试 - 由于应用的状态保存在 store 中，并且不直接与浏览器 DOM 交互，因此您的测试将更易于预测和复制。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">28. React diff 原理</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p>把树形结构按照层级分解，只比较同级元素。</p>
</li>
<li><p>列表结构的每个单元添加唯一的 key 属性，方便比较。</p>
</li>
<li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>
</li>
<li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>
</li>
<li><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">71. 类组件的setState和函数组件的useState异同</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>相同点</p>
<p>都更新视图，底部调用了scheduleUpdateFiber方法，在事件驱动情况下都有批量更新规则。</p>
<p>不同点</p>
<p>setState只要调用了就会执行更新；useState会浅比较2次state是否相同</p>
<p>setState有专门监听变化的回调函数；useState只能通过useEffect</p>
<p>setState底层处理上主要是和老的state合并；useState则重新赋值</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">58. 什么是React调和？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li>调和是 React 的一种算法，用于区分一棵元素树和另一棵元素树，以确定需要替换的部分。
调和是我们过去所说的虚拟 DOM 背后的算法。其定义听起来是这样的：当您渲染 React 应用程序时，描述应用程序的元素树会在预留内存中生成。然后，这棵树就会被包含在呈现环境中，例如，在浏览器应用程序中，它会被转化为一组 DOM 操作。应用状态更新时，会生成新的元素树。新的树会与之前的树进行比较，以便准确计算和启用重新绘制更新后的应用程序所需的操作。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 在React中如何避免不必要的render？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点</p>
<ul>
<li>shouldComponentUpdate 和 PureComponent</li>
</ul>
<p>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。</p>
<ul>
<li>利用高阶组件</li>
</ul>
<p>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能</p>
<ul>
<li>使用 React.memo</li>
</ul>
<p>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">54. 在什么情况下可以使用本地状态，什么时候应该使用全局状态？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>如果本地状态仅在一个组件中使用并且不打算将其传递给其他组件，则建议使用本地状态。本地状态也用在表示列表中单个项目的组件中。但是，如果组件分解涉及嵌套组件且数据沿层次结构传递，则最好使用全局状态。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">72. 为什么React组件中 return 一个对象而不是一个元素时会报错</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>因为对象不具备迭代接口，必须要时原型或者自己身上有[Symbol.iterator]属性才可以，而数组是有迭代接口的，所以可以直接迭代。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">73. React可以在哪个生命周期访问DOM，在哪个时机访问Ref？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>访问 DOM： 在 React 中，通常应该遈避免直接操作 DOM，因为 React 采用 Virtual DOM 的方式管理页面渲染。但是，如果确实需要访问真实的 DOM 元素，可以在组件的以下生命周期方法中进行</p>
<p>componentDidMount()：在组件挂载后立即调用。可以在这个生命周期方法中访问和操作 DOM 元素，执行初始化操作等。</p>
<p>componentDidUpdate(prevProps, prevState)：在组件更新后被调用。可以在此方法中根据更新后的 props 或 state 来访问或操作 DOM 元素。</p>
<p>访问 Ref： Ref 是用于访问真实 DOM 节点或 React 组件实例的一种方式。在 React 中，可以在以下时机访问 Ref：</p>
<p>使用 Ref：可以在componentDidMount()、componentDidUpdate() 或事件处理程序中访问 Ref。通过 Ref 可以获取到对应的 DOM 元素或组件实例。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">52. 如何跟踪功能组件的卸载？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><p>通常，useEffect 创建的资源需要在组件离开屏幕前进行清理或重置，例如订阅或计时器标识符。
为此，传递给 useEffect 的函数可以返回一个清理函数。清理函数将在组件从用户界面移除之前运行，以防止内存泄漏。此外，如果组件渲染多次（通常是这种情况），则会在执行下一个效果之前清理前一个效果。</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-title function_">setValue</span>(value);
  }
  <span class="hljs-title class_">SomeAPI</span>.<span class="hljs-title function_">doFunction</span>(id, handleChange);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title class_">SomeAPI</span>.<span class="hljs-title function_">undoFunction</span>(id, handleChange);
  };
})
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly (Wasm) 的核心特点有哪些？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>  高性能：WebAssembly 的字节码格式在浏览器中编译运行接近原生速度，非常适合对性能要求高的任务。</li>
<li><strong>1：</strong>  跨平台支持：WebAssembly 是浏览器标准，适用于 Chrome、Firefox、Safari 等主流浏览器，且具备良好的跨平台兼容性。</li>
<li><strong>1：</strong>  安全性：Wasm 运行在沙盒环境，不能直接访问宿主机器资源，符合 Web 的安全模型。</li>
<li><strong>1：</strong>  语言多样性：支持 C、C++、Rust 等多种语言，弥补了 JavaScript 仅限于单语言开发的不足。</li>
<li><strong>1：</strong>  小体积：Wasm 格式文件较小，传输高效，加载速度快。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 在开发模式下如何实现快速启动？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 生产构建的主要优化策略有哪些？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="inner-content"><details>

<ul>
<li><strong>1：</strong> 依赖预打包<br>
&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>
&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。</li>
<li><strong>1：</strong> 代码压缩与混淆:<br>
&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>
&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre><p>经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。</p>
<ul>
<li><p><strong>1：</strong> CSS 优化:</br>
&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>
&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。</p>
</li>
<li><p><strong>1：</strong> 静态资源处理:</br>
&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>
&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。</p>
</li>
<li><p><strong>2：</strong> Tree - Shaking（摇树优化）:</br>
&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>
&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。</p>
</li>
</ul>
</details>

</div></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><p><strong>1：</strong> esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。</p>
</li>
<li><p><strong>1：</strong> Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。</p>
</li>
<li><p><strong>1：</strong> 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">13. webpack的Plugin和Loader的区别</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong>【Loader】：用于对模块源码的转换， loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。</li>
<li><strong>1：</strong>【Plugin】：目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何处理 CSS 模块？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. proxy是工作原理？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-title function_">proxy</span>({<span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.example.org&#x27;</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
}));
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">8. webpack代理怎么配置？proxy中常用的属性是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 配置如下：</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),
    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&quot;/api&quot;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;https://api.github.com&quot;</span>,<span class="hljs-comment">// </span>
      },
    },
    <span class="hljs-comment">// ...</span>
  },
};
</code></pre><ul>
<li><strong>2：</strong> 常用属性：</li>
</ul>
<blockquote>
<p>target：表示的是代理到的目标地址<br>pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除、可以使用pathRewrite<br>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false<br>changeOrigin：它表示是否更新代理后请求的 headers 中host地址  </p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">对Service Worker的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</li>
<li><strong>4：</strong><ul>
<li>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存</li>
<li>存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
<li>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">什么是 WebAssembly？其主要用途是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> WebAssembly（简称 Wasm）是一种能够在浏览器中运行的低级二进制格式，设计用于高效、跨平台的计算密集型应用。它由 W3C 标准化，可在主流浏览器中运行。WebAssembly 允许开发者使用多种编程语言（如 C、C++、Rust）编写代码，然后将代码编译为 WebAssembly 模块，使其在浏览器中高效运行。其主要用途包括：</li>
<li><strong>1：</strong> 高性能计算：如游戏引擎、视频和图像处理。</li>
<li><strong>1：</strong> 跨平台：编译成字节码后能在多种平台（桌面端、移动端、嵌入式设备）上运行。</li>
<li><strong>1：</strong> 后端计算转移：如数据加密、解压缩等密集型运算从服务器转移到客户端。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">15. webpack中的Loader如何编写？</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>5：</strong> loader 的本质其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader 设为一个箭头函数。
函数接受一个参数，为 webpack 传递给 loader 的文件源内容函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer。</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//导出一个函数，source为webpack传递给loader的文件源内容</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>){
 <span class="hljs-keyword">const</span> content = <span class="hljs-title function_">doSomeThing2JsString</span>(source);
<span class="hljs-comment">//如果 loader 配置了 options 对象，那么this.query将指向 options</span>
<span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-property">query</span>;
<span class="hljs-comment">// 可以用作解析其他模块路径的上下文</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this.context&#x27;</span>);
<span class="hljs-comment">/*
* this.callback 参数:
* error:Error |null，当 loader 出错时向外抛出一个 error
* content:String | Buffer，经过 loader 编译后需要导出的内容
* sourceMap:为方便调试生成的编译后内容的 source map* ast:本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST.进而省去重复生成 AST 的过程
*/</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>，content);<span class="hljs-comment">//异步</span>
<span class="hljs-keyword">return</span> content;<span class="hljs-comment">//同步</span>
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">14. webpack常见的提升构建速度的方法</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 常见的有一下几种：</li>
</ul>
<blockquote>
<p>优化 loader 配置<br>合理使用 resolve.extensions<br>优化 resolve.modules<br>优化 resolve.alias<br>使用 DLLPlugin 插件<br>使用 cache-loader<br>terser 启动多线程<br>合理使用 sourceMap</p>
</blockquote>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. 简述webpack的构建流程？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li><strong>1：</strong> 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理</li>
<li><strong>1：</strong> 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统
<img src="/public/images/image2.png" alt="alt text"></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. webpack proxy 为什么能解决跨域？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，
代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。<br>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。<br><strong>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。</strong></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何支持 TypeScript？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 通过插件系统支持 TypeScript，无需额外配置即可直接处理 TypeScript 文件。Vite 在内部使用 esbuild 预处理 TypeScript 文件，这不仅提高了编译速度，还简化了配置过程。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. webpack 中提供服务器的工具是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><details class="inner-content"><ul>
<li><strong>1：</strong> webpack 中提供服务器的工具为 webpack-dev-server</li>
</ul>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-01-23T09:24:00.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"BP_TxIHV\",\"ing.md\":\"BTlz652q\",\"readme.md\":\"CdlIUM7x\",\"src_guide_getting-started.md\":\"DsIuXUmz\",\"src_guide_why.md\":\"DICU16--\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"mhKAlk1x\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"Cds9atPm\",\"src_questions_computer-base_1_计算机硬件.md\":\"BNQ0oi4i\",\"src_questions_computer-base_2_计算机软件.md\":\"B-O2yYhP\",\"src_questions_computer-base_3_计算机网络.md\":\"BGXTQytO\",\"src_questions_computer-base_4_计算机编程.md\":\"DZl-gJMP\",\"src_questions_computer-base_5_计算机科学.md\":\"pxlEgk5w\",\"src_questions_computer-base_6_软件工程.md\":\"D9h9vIc_\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"DAP_-gcv\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"BY2kYmi9\",\"src_questions_data-structures-algorithms_1_算法.md\":\"DQAB3ZI8\",\"src_questions_front-architect_1_前端架构.md\":\"DxC4B600\",\"src_questions_front-base_1_html.md\":\"BZGhlZmN\",\"src_questions_front-base_2_css.md\":\"DyrZnojH\",\"src_questions_front-base_3_javascript.md\":\"BpT-JlYq\",\"src_questions_front-base_4_typescript.md\":\"CvIlqq_Q\",\"src_questions_front-component_1_ui组件库.md\":\"DK5uy_1O\",\"src_questions_front-component_2_业务组件库.md\":\"CYAj83vP\",\"src_questions_front-engineering_1_前端标准化.md\":\"DLdgtD32\",\"src_questions_front-engineering_2_前端自动化.md\":\"DDRmb11U\",\"src_questions_front-engineering_3_webpack.md\":\"DFS2rCSX\",\"src_questions_front-engineering_4_vite.md\":\"CgZSza5l\",\"src_questions_front-engineering_5_rollup.md\":\"BKUdBkr4\",\"src_questions_front-frame_1_react.md\":\"y7s-Q_Mf\",\"src_questions_front-frame_2_vue.md\":\"B9EuzilL\",\"src_questions_front-frame_3_next.md\":\"BAN9nN-I\",\"src_questions_front-frame_4_nuxt.md\":\"p8cuMmzf\",\"src_questions_front-frame_5_qiankun.md\":\"BhOhJHVF\",\"src_questions_front-newest_1_前端最前沿.md\":\"wqgPqed2\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DkHV1hXw\",\"src_questions_front-runtime_1_浏览器.md\":\"CxBGSIZK\",\"src_questions_front-runtime_2_nodejs.md\":\"CShCETBq\",\"src_questions_front-safety_1_前端安全.md\":\"B_0PvkJ-\",\"src_questions_server_1_nest.md\":\"BnEM9Svy\",\"src_questions_server_2_mongodb.md\":\"Dp3noJWv\",\"src_questions_server_3_mysql.md\":\"BTxDhMeo\",\"src_questions_server_4_nginx.md\":\"BKMbFl3q\",\"src_questions_server_5_docker.md\":\"CTFM9gyn\",\"src_questions_server_6_kubernets.md\":\"C_52BOQs\",\"src_questions_server_7_nacos.md\":\"CnOJvaYn\",\"src_questions_server_8_redis.md\":\"c_c8QzQI\",\"src_training_training-architecture_index.md\":\"CiiOByY3\",\"src_training_training-experts_index.md\":\"Bz3t2kbY\",\"src_training_training-intermediate_index.md\":\"JuMH5FRI\",\"src_training_training-primary_index.md\":\"BLScaYNZ\",\"src_training_training-senior_index.md\":\"CeCfNjBn\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>