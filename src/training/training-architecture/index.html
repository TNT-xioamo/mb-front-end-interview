<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题库</title>
    <meta name="description" content="致力于为前端人员提供全面可靠的专业知识">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/mb-front-end-interview/assets/style.DV7oKBPG.css" as="style">
    <link rel="preload stylesheet" href="/mb-front-end-interview/vp-icons.css" as="style">
    
    <script type="module" src="/mb-front-end-interview/assets/app.CM8PMWxc.js"></script>
    <link rel="preload" href="/mb-front-end-interview/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/theme.B4KhxFlP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/framework.Dvg3AjVP.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/chunks/markdownDialog.bH4w96rB.js">
    <link rel="modulepreload" href="/mb-front-end-interview/assets/src_training_training-architecture_index.md.Ckz7gu8O.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-9f43907a><a class="title" href="/mb-front-end-interview/" data-v-9f43907a><!--[--><!--]--><!----><span data-v-9f43907a>前端面试题库</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/guide/why.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>指南</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/mb-front-end-interview/src/questions/front-base/1_HTML.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>题库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/mb-front-end-interview/src/training/training-primary/index.html" tabindex="0" data-v-afb2845e data-v-815115f5><!--[--><span data-v-815115f5>训练</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-bfe7971f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-bfe7971f><span class="vpi-more-horizontal icon" data-v-bfe7971f></span></button><div class="menu" data-v-bfe7971f><div class="VPMenu" data-v-bfe7971f data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>主题</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/syh-micro-build/mb-front-end-interview" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-60a9a2d3><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>菜单</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>回到顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>初级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-primary/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>中级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-intermediate/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>高级</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed has-active" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>架构</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-architecture/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 collapsible collapsed" data-v-51288d80 data-v-edd2eed8><div class="item" role="button" tabindex="0" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><h2 class="text" data-v-edd2eed8>专家</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-edd2eed8><span class="vpi-chevron-right caret-icon" data-v-edd2eed8></span></div></div><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>开始训练</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>页面导航</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _mb-front-end-interview_src_training_training-architecture_" data-v-e6f2a212><div><!----><div class="main-box"><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 开发环境和生产环境的构建流程有什么不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 开发环境：Vite 利用浏览器原生 ES 模块支持，无需打包，服务器直接按需提供模块内容。同时，会对依赖进行预构建，将非 ESM 格式的依赖转换为 ESM 格式并缓存。热更新时只更新变更的模块。</li>
<li><strong>1：</strong> 生产环境：Vite 使用 Rollup 进行打包，将所有模块打包成一个或多个静态文件，同时进行代码压缩、分割等优化操作，生成适合生产环境部署的文件。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">esbuild 和 rollup 都是 vite 的基础依赖， 那么他们有啥不同？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p><strong>1：</strong> esbuild：esbuild 是一个快速、可扩展的 JavaScript 打包器，它被用作 Vite 的默认构建工具。esbuild 的主要任务是将源代码转换为浏览器可以理解的代码，同时还支持压缩、代码分割、按需加载等功能。esbuild 利用其高性能的构建能力，实现了快速的开发服务器和热模块替换。</p>
</li>
<li><p><strong>1：</strong> Rollup：Rollup 是一个 JavaScript 模块打包工具，也是 Vite 的另一个基础依赖。在 Vite 中，Rollup 主要用于生产构建阶段。它通过静态分析模块依赖关系，将多个模块打包为一个或多个最终的输出文件。Rollup 支持多种输出格式，如 ES 模块、CommonJS、UMD 等，可以根据项目的需要进行配置。</p>
</li>
<li><p><strong>1：</strong> 尽管 esbuild 和 Rollup 都是 Vite 的基础依赖，但它们的分工是不同的。esbuild 用于开发服务器阶段，通过实时编译和提供模块来实现快速的冷启动和热模块替换。而 Rollup 用于生产构建阶段，将源代码打包为最终可发布的文件，以用于部署到生产环境。这样的分工使得 Vite 在开发过程中能够快速响应变化，并在构建过程中生成高效的最终输出文件。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">对Service Worker的理解</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</li>
<li><strong>4：</strong><ul>
<li>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存</li>
<li>存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
<li>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了,在Cache中也可以发现所需的文件已被缓存</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">4. 简述webpack的构建流程？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>
<li><strong>1：</strong> 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找.到该 Module 依赖的 Module，递归地进行编译处理</li>
<li><strong>1：</strong> 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统
<img src="/public/images/image2.png" alt="alt text"></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">10. webpack proxy 为什么能解决跨域？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题通过设置 webpack proxy 实现代理请求后，相当于浏览器与服务端中添加一个代理者当本地发送请求的时候，
代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。<br>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据。<br><strong>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。</strong></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 与传统的 Webpack 打包工具有何不同？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 主要区别在于其开发模式的实现方式。Vite 在开发时不需要打包，而是直接通过浏览器加载模块，这使得启动速度更快。而 Webpack 在开发模式下仍然需要进行打包和热重载，这通常会更慢。此外，Vite 在生产构建时也采用了更现代的打包策略，如 Rollup，优化了打包输出。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">9. proxy是工作原理？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-title function_">proxy</span>({<span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.example.org&#x27;</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
}));
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 生产构建的主要优化策略有哪些？</h4><div class="head-re"><span class="head-score">6 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>1：</strong> 依赖预打包<br>
&emsp;原理：在生产构建时，Vite 会对项目的依赖进行预打包。因为在开发阶段，Vite 利用浏览器原生的 ES 模块加载，每个依赖都是单独的模块请求。但在生产环境中，过多的小模块请求会影响性能。Vite 将多个依赖模块合并为一个或几个较大的 chunk 文件，减少 HTTP 请求数量。<br>
&emsp;示例：比如一个项目使用了 lodash、axios 等多个库，Vite 会把这些库的相关模块打包到一起。假设在开发时，加载这些库可能会产生 10 个小的模块请求，经过预打包后可能只需要 1 - 2 个请求来加载这些库的代码。</li>
<li><strong>1：</strong> 代码压缩与混淆:<br>
&emsp;原理： Vite 使用工具（如 Terser）对 JavaScript 代码进行压缩和混淆。压缩是去除代码中的空格、注释等冗余信息，减小文件体积。混淆则是将变量名、函数名等替换为更短或难以理解的名称，增加代码的安全性并且进一步减小体积。<br>
&emsp;示例: 原始的 JavaScript 代码可能包含大量的注释和有意义的变量名如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre><p>经过压缩和混淆后可能变成类似function n(a,b){return a + b;}的形式，文件大小也会显著减小。</p>
<ul>
<li><p><strong>1：</strong> CSS 优化:</br>
&emsp;(1)提取公共 CSS：Vite 会将多个组件或模块中相同的 CSS 样式提取出来，合并到一个或多个 CSS 文件中。这样可以避免在每个组件的 HTML 文件中重复加载相同的 CSS 代码，减少文件大小和请求次数。</br>
&emsp;(2)压缩 CSS：使用工具（如 cssnano）对 CSS 文件进行压缩，去除不必要的空格、注释，优化 CSS 属性的表示方式等。例如，将color: #ffffff;可能会被优化为color:#fff;。</p>
</li>
<li><p><strong>1：</strong> 静态资源处理:</br>
&emsp;(1)哈希处理：对静态资源（如图片、字体等）进行哈希处理。当资源内容发生变化时，其哈希值也会改变，这样可以在浏览器中实现长效缓存。浏览器可以根据资源的哈希值判断是否需要重新请求资源。</br>
&emsp;(2)优化路径和加载方式：确保在生产环境中，静态资源的路径是正确的，并且以最优的方式加载。例如，对于一些小的图片，可能会被转换为 Base64 格式嵌入到 CSS 或 HTML 文件中，减少额外的请求。</p>
</li>
<li><p><strong>2：</strong> Tree - Shaking（摇树优化）:</br>
&emsp;原理：Vite 会分析代码的依赖关系，在打包过程中去除那些没有被实际使用的代码。例如，如果在一个 JavaScript 模块中引入了一个大型库，但只使用了其中的一个小功能，Vite 会将未使用的代码部分剔除。</br>
&emsp;示例：假设一个项目引入了lodash库，但只使用了_.isEmpty函数，Vite 会在打包时将lodash中其他未使用的函数代码排除，从而减小最终打包文件的大小。</p>
</li>
</ul>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 项目构建速度快的原因是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> Vite 利用了现代浏览器的原生 ES （ES Modules）模块支持，采用了按需加载和热更新技术。在开发过程中，它只加载和处理当前需要的模块，减少了不必要的代码编译和打包工作，并且通过快速
的热更新机制，使开发过程中能够迅速响应代码变化，提高了构建速度。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">当 Vite 热更新失效时，可能的原因有哪些？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 配置问题：检查 vite.config.js 中是否有影响热更新的配置，如 server.hmr 配置错误。</li>
<li><strong>1：</strong> 代码问题：某些代码结构或语法可能导致热更新失效，例如在模块顶层使用 const 定义的对象或函数被修改，可能无法触发热更新。</li>
<li><strong>1：</strong> 插件冲突：使用的某些插件可能与 Vite 的热更新机制冲突，尝试禁用部分插件排查问题。</li>
<li><strong>1：</strong> 浏览器缓存：浏览器缓存可能会影响热更新，尝试清空浏览器缓存或使用无痕模式。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">5. webpack proxy是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> webpack proxy，是 webpack 提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器，其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 如何处理 CSS 模块？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 对 CSS 模块有内置支持，会将 CSS 模块中的类名转换为唯一的哈希值，以避免全局样式冲突。并且可以通过 import 语句引入 CSS 模块，在 JavaScript 文件中使用其导出的类名对象来应用样式到相应元素。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">6. webpack 中提供服务器的工具是什么？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> webpack 中提供服务器的工具为 webpack-dev-server</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">11. webpack的loader是什么？为什么使用它？它有哪几种配置方式</h4><div class="head-re"><span class="head-score">5 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> loader 用于对模块的&quot;源代码&quot;进行转换，在 import 或&quot;加载&quot;模块时预处理文件</li>
<li><strong>1：</strong> webpack 做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。<br>在 webpack 内部中，任何文件都是模块，不仅仅只是js 文件。默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json文件打包，像 css、 sass、 png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析。</li>
<li><strong>3：</strong> 关于配置 loader 的方式有三种:<blockquote>
<p>配置方式(推荐)：在 webpack.config.js文件中指定 loader<br>内联方式：在每个 import 语句中显式指定 loader<br>Cl 方式：在 shell 命令中指定它们</p>
</blockquote>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">2. webpack 中如何配置开启热更新？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong></li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">devServer</span>: {
    <span class="hljs-comment">// HMR</span>
    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// hotOnly: true</span>
  },
};
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">在 Vite 项目中如何配置代理（Proxy）以解决跨域问题？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在 vite.config.js 中配置 server.proxy 选项，例如：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://backend-api-url&#x27;</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>)
      }
    }
  }
};
<span class="hljs-comment">// 这会将所有以 /api 开头的请求代理到指定的后端 API 地址，并根据 rewrite 规则修改请求路径。</span>
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">WebAssembly 的工作原理是什么？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 编写源代码：使用支持 WebAssembly 的语言（如 C、C++ 或 Rust）编写源代码。</li>
<li><strong>1：</strong> 编译为 WebAssembly 模块：将源代码编译为 .wasm 文件，这是 WebAssembly 的二进制格式。</li>
<li><strong>1：</strong> 在浏览器中加载和运行：通过 JavaScript 在浏览器中加载 .wasm 文件并实例化。</li>
<li><strong>1：</strong> 执行 WebAssembly 函数：JavaScript 调用 WebAssembly 函数，执行高性能计算任务。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">Vite 在开发模式下如何实现快速启动？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> Vite 利用 ES 模块的原生支持，通过浏览器直接加载模块文件，避免了传统打包工具的打包和重构过程。这种方式大大减少了启动时间，实现了快速的热更新和模块替换。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. webpack 的热更新原理?</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 架构</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 在编写未经过 webpack 打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle 文件，传输给 Bundle Server 静态资源服务器，</li>
<li><strong>1：</strong> 当某一个文件或者模块发生变化时，webpack 监听到文件变化对文件重新编译打包，编译生成唯一的hash 值，这个 hash 值用来作为下一次热更新的标识根据变化的内容生成两个补丁文件: manifest (包含了 hash 和 chundId ，用来说明变化的内容)和 chunk.js 模块。</li>
<li><strong>1：</strong> 由于 socket 服务器在 HMR Runtime 和 HMR Server 之间建立 websocket 链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的 hash 值，如下图的h 属性，作为下一次热更细的标识</li>
<li><strong>1：</strong> 在浏览器接受到这条消息之前，浏览器已经在上一次 socket 消息中已经记住了此时的 hash 标识这时候我们会创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件mainfest 文件包含重新 build 生成的 hash 值，以及变化的模块，对应上图的 c 属性浏览器根据 manifest 文件获取模块变化的内容，从而触发 render 流程，实现局部模块更新。
<img src="/public/images/image.png" alt="alt text"></li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">23. 解释 TypeScript 中的类型断言（Type Assertion）及其作用</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>1：</strong> 类型断言是一种告诉编译器某个值的类型的方式，它允许开发者手动指定一个值的类型，而不是让编译器自动推断。有两种语法形式：as语法和尖括号语法。例如：</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// as语法</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (someValue <span class="hljs-keyword">as</span> string).<span class="hljs-property">length</span>;

<span class="hljs-comment">// 尖括号语法</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: any = <span class="hljs-string">&quot;this is a string&quot;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: number = (&lt;string&gt;someValue).<span class="hljs-property">length</span>;
</code></pre><ul>
<li><strong>1：</strong> 类型断言的作用主要是在某些情况下，当编译器无法准确推断类型或者开发者确定某个值的类型时，通过类型断言来告诉编译器，以便进行更准确的类型检查和代码提示，避免类型错误。</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. DNS 协议是什么</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">16. 组件中写 name 选项有哪些好处？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）</p>
</li>
<li><p>可以通过 name 属性实现缓存功能（keep-alive）</p>
</li>
<li><p>可以通过 name 来识别组件（跨级组件通信时非常重要）</p>
</li>
<li><p>使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">33. 怎么理解Vue的单向数据流？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>单向数据流是指：数据在组件树中的流动方向，是从父组件流向子组件的。这个设计使得数据流更加可预测和易于调试，确保应用状态的一致性。</p>
<p>简单理解：父组件的状态对于子组件是只读的，子组件想改，只能通过事件的方式，通知父组件自己改。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">3. var 、let 、 const 的区别是什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`</div><details class="inner-content"><ul>
<li><strong>1：</strong> var 作用域: 函数作用域（如果在函数内部声明），全局作用域（如果在函数外部声明）;
        提升: 声明和初始化都会被提升（变量提升，但未初始化时是 undefined）;</li>
<li><strong>1：</strong> let、 const 作用域: 级作用域（只在其所在的代码块内有效）;
    提升: 变量提升但不会初始化，存在“暂时性死区”，即在声明之前不能访问;</li>
<li><strong>1：</strong> 区别:
      const： 需要在声明时初始化，且之后不能被修改;
      let：可以修改其值;
      var： 是函数作用域或全局作用域，let 和 const 是块级作用域;</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">59. 如何在 Redux Thunk 中处理异步操作？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>要使用 Redux Thunk，需要将其作为中间件导入。Action创建者不应只返回一个对象，而应返回一个将dispatch 作为参数的函数。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">addUser</span> = (<span class="hljs-params">{ firstName, lastName }</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserStart</span>());
  }

  axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/users&#x27;</span>, {
    firstName,
    lastName,
    <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserSuccess</span>(res.<span class="hljs-property">data</span>));
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addUserError</span>(error.<span class="hljs-property">message</span>));
  })
}
</code></pre></details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">66. 说说React Hooks是如何解决类组件中一些常见问题的</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>React Hooks允许我们在不编写class的情况下使用state以及其他的React特性。</p>
</li>
<li><p>这解决了类组件中一些常见问题，如代码复用困难、逻辑难以拆分以及生命周期方法难以管理等。</p>
</li>
<li><p>通过使用Hooks，我们可以将组件逻辑提取到可重用的函数中，使得代码更加简洁、易读和可维护。</p>
</li>
<li><p>此外，Hooks还提供了更灵活的方式来管理组件的状态和生命周期，使得组件逻辑更加清晰和可预测。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">50. React中的setState和replaceState的区别是什么？</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>（1）setState() setState()用于设置状态对象，其语法如下：</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">setState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会和当前的state合并</p>
</li>
<li><p>callback，可选参数。回调函数。将在组件重新渲染后执行。在这个回调函数中你可以拿到更新后 state 的值</p>
</li>
</ul>
<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。</p>
<p>（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下</p>
<pre><code class="hljs language-js">
<span class="hljs-title function_">replaceState</span>(object nextState[, <span class="hljs-keyword">function</span> callback])
</code></pre><ul>
<li><p>nextState，将要设置的新状态，该状态会替换当前的state。</p>
</li>
<li><p>callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>
</li>
</ul>
<p>总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. react无状态组件和class类组件的区别？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>直观区别，函数组件代码量较少，相比类组件更加简洁</p>
</li>
<li><p>函数组件看似只是一个返回react元素的函数，其实体现的是无状态组件的思想，函数组件中没有this， 没有state，也没有生命周期，这就决定了函数组件都是展示性组件，接收props，渲染dom，而不关注其他逻辑</p>
</li>
<li><p>因为函数组件不需要考虑组件状态和组件生命周期方法中的各种比较校验，所以有很大的性能提升空间</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">25. react如何做到和vue中keep-alive的缓存效果</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li>React Keep Alive 提供了 ，必须把 放在 Provider 里面，并且每个 组件都必须拥有一个唯一的 key</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">57. Redux和Mobx有什么区别？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>Redux 是一种更简单、更有主见的状态管理库，它遵循严格的单向数据流，并提倡不变性。它需要更多的模板代码和显式更新，但与 React 的集成度很高。</p>
</li>
<li><p>Mobx 提供的 API 更灵活、更直观，模板代码更少。它允许你直接修改状态，并自动跟踪变化以获得更好的性能。在 Redux 和 Mobx 之间做出选择取决于您的具体需求和偏好。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">协商缓存和强缓存的区别</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 业务</div><div class="head-tips">级别: `W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><strong>2：</strong> 强缓存<ul>
<li>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</li>
<li>设置方式：分别是 http 响应头信息中的 Expires 属性和 Cache-Control 属性。</li>
</ul>
</li>
<li><strong>2：</strong> 协商缓存<ul>
<li>如果命中强制缓存，就无需发起新的请求，直接使用缓存资源，如果没有命中强制缓存，且设置了协商缓存，这个时候协商缓存就会发挥作用了。</li>
<li>设置方式：分别是 http请求头中if-modified-since和if-none-match 响应 头信息中的 Etag 和 Last-Modified 属性。</li>
</ul>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">24. 如何判断一个元素是否在可视区域内？</h4><div class="head-re"><span class="head-score">4 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>1：用途</strong></li>
</ul>
<p>可视区域即我们浏览网页的设备肉眼可见的区域，如下图</p>
<p><img src="/public/images/3_JavaScript_20241230001543.png" alt=""></p>
<p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p>
<blockquote>
<ul>
<li>图片的懒加载</li>
<li>列表的无限滚动</li>
<li>计算广告元素的曝光情况</li>
<li>可点击链接的预加载</li>
</ul>
</blockquote>
<ul>
<li><strong>实现方式: 3</strong></li>
</ul>
<p><code>offsetTop</code>，元素的上外边框至包含元素的上内边框之间的像素距离，其他<code>offset</code>属性如下图所示：</p>
<p><img src="/public/images/3_JavaScript_20241230001827.png" alt=""></p>
<p>下面再来了解下<code>clientWidth</code>、<code>clientHeight</code>：</p>
<ul>
<li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度，即<code>clientWidth = content + padding</code></li>
<li><code>clientHeight</code>：元素内容区高度加上上下内边距高度，即<code>clientHeight = content + padding</code></li>
</ul>
<p>这里可以看到<code>client</code>元素都不包括外边距</p>
<p>最后，关于<code>scroll</code>系列的属性如下：</p>
<ul>
<li><p><code>scrollWidth</code> 和 <code>scrollHeight</code> 主要用于确定元素内容的实际大小</p>
</li>
<li><p><code>scrollLeft</code> 和 <code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置</p>
</li>
<li><p>垂直滚动 <code>scrollTop &gt; 0</code></p>
</li>
<li><p>水平滚动 <code>scrollLeft &gt; 0</code></p>
</li>
<li><p>将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置</p>
</li>
<li><p>上述属性都是只读的，每次访问都要重新开始</p>
</li>
</ul>
<p>下面再看看如何实现判断：</p>
<p>公式如下：</p>
<pre><code class="hljs language-js">el.<span class="hljs-property">offsetTop</span> - <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> &lt;= viewPortHeight
</code></pre><p>代码实现：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPortOfOne</span> (<span class="hljs-params">el</span>) {
    <span class="hljs-comment">// viewPortHeight 兼容所有浏览器写法</span>
    <span class="hljs-keyword">const</span> viewPortHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span> 
    <span class="hljs-keyword">const</span> offsetTop = el.<span class="hljs-property">offsetTop</span>
    <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>
    <span class="hljs-keyword">const</span> top = offsetTop - scrollTop
    <span class="hljs-keyword">return</span> top &lt;= viewPortHeight
}
</code></pre><p>返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.target&#x27;</span>);
<span class="hljs-keyword">const</span> clientRect = target.<span class="hljs-title function_">getBoundingClientRect</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clientRect);

<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   bottom: 556.21875,</span>
<span class="hljs-comment">//   height: 393.59375,</span>
<span class="hljs-comment">//   left: 333,</span>
<span class="hljs-comment">//   right: 1017,</span>
<span class="hljs-comment">//   top: 162.625,</span>
<span class="hljs-comment">//   width: 684</span>
<span class="hljs-comment">// }</span>
</code></pre><p>属性对应的关系图如下所示：</p>
<p><img src="/public/images/3_JavaScript_20241230002050.png" alt=""></p>
<p>当页面发生滚动的时候，<code>top</code>与<code>left</code>属性值都会随之改变</p>
<p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p>
<ul>
<li>top 大于等于 0</li>
<li>left 大于等于 0</li>
<li>bottom 小于等于视窗高度</li>
<li>right 小于等于视窗宽度</li>
</ul>
<p>实现代码如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPort</span>(<span class="hljs-params">element</span>) {
  <span class="hljs-keyword">const</span> viewWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>;
  <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;
  <span class="hljs-keyword">const</span> {
    top,
    right,
    bottom,
    left,
  } = element.<span class="hljs-title function_">getBoundingClientRect</span>();

  <span class="hljs-keyword">return</span> (
    top &gt;= <span class="hljs-number">0</span> &amp;&amp;
    left &gt;= <span class="hljs-number">0</span> &amp;&amp;
    right &lt;= viewWidth &amp;&amp;
    bottom &lt;= viewHeight
  );
}
</code></pre><p><code>Intersection Observer</code> 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比 <code>getBoundingClientRect</code> 会好很多</p>
<p>使用步骤主要分为两步：创建观察者和传入被观察者</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> options = {
  <span class="hljs-comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span>
  <span class="hljs-comment">// 1 表示完全被包含</span>
  <span class="hljs-attr">threshold</span>: <span class="hljs-number">1.0</span>, 
  <span class="hljs-attr">root</span>:<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#scrollArea&#x27;</span>) <span class="hljs-comment">// 必须是目标元素的父级元素</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">entries, observer</span>) =&gt; { ....}

<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(callback, options);
</code></pre><p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的参数 <code>callback</code> 在重叠比例超过 <code>threshold</code> 时会被执行`</p>
<p>关于<code>callback</code>回调函数常用属性如下：</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 上段代码中被省略的 callback</span>
<span class="hljs-keyword">const</span> callback = <span class="hljs-keyword">function</span>(<span class="hljs-params">entries, observer</span>) { 
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
        entry.<span class="hljs-property">time</span>;               <span class="hljs-comment">// 触发的时间</span>
        entry.<span class="hljs-property">rootBounds</span>;         <span class="hljs-comment">// 根元素的位置矩形，这种情况下为视窗位置</span>
        entry.<span class="hljs-property">boundingClientRect</span>; <span class="hljs-comment">// 被观察者的位置举行</span>
        entry.<span class="hljs-property">intersectionRect</span>;   <span class="hljs-comment">// 重叠区域的位置矩形</span>
        entry.<span class="hljs-property">intersectionRatio</span>;  <span class="hljs-comment">// 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）</span>
        entry.<span class="hljs-property">target</span>;             <span class="hljs-comment">// 被观察者</span>
    });
};
</code></pre><p>通过 <code>observer.observe(target)</code> 这一行代码即可简单的注册被观察者</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.target&#x27;</span>);
observer.<span class="hljs-title function_">observe</span>(target);
</code></pre><p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p>
<p><code>Html</code>结构如下：</p>
<pre><code class="hljs language-js">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;&lt;/div&gt;
</code></pre><p><code>css</code>样式如下：</p>
<pre><code class="hljs language-css">.<span class="hljs-property">container</span> {
    <span class="hljs-attr">display</span>: flex;
    flex-<span class="hljs-attr">wrap</span>: wrap;
}
.<span class="hljs-property">target</span> {
    <span class="hljs-attr">margin</span>: 5px;
    <span class="hljs-attr">width</span>: 20px;
    <span class="hljs-attr">height</span>: 20px;
    <span class="hljs-attr">background</span>: red;
}
</code></pre><p>往<code>container</code>插入1000个元素</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> $container = $(<span class="hljs-string">&quot;.container&quot;</span>);

<span class="hljs-comment">// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createTargets</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> htmlString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>)
    .<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#x27;</span>)
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);
  $container.<span class="hljs-title function_">html</span>(htmlString);
}
</code></pre><p>这里，首先使用 <code>getBoundingClientRect</code> 方法进行判断元素是否在可视区域</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPort</span>(<span class="hljs-params">element</span>) {
    <span class="hljs-keyword">const</span> viewWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>;
    <span class="hljs-keyword">const</span> viewHeight =
          <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;
    <span class="hljs-keyword">const</span> { top, right, bottom, left } = element.<span class="hljs-title function_">getBoundingClientRect</span>();

    <span class="hljs-keyword">return</span> top &gt;= <span class="hljs-number">0</span> &amp;&amp; left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;
}
</code></pre><p>然后开始监听<code>scroll</code>事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为<code>yellow</code></p>
<pre><code class="hljs language-js">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;scroll !&quot;</span>);
    $targets.<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, element</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isInViewPort</span>(element)) {
            $(element).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>);
        }
    });
});
</code></pre><p>通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了<code>scroll</code>事件，<code>scroll</code>事件伴随了大量的计算，会造成资源方面的浪费</p>
<p>下面通过<code>Intersection Observer</code>的形式同样实现相同的功能</p>
<p>首先创建一个观察者</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(getYellow, { <span class="hljs-attr">threshold</span>: <span class="hljs-number">1.0</span> });
</code></pre><p><code>getYellow</code>回调函数实现对背景颜色改变，如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getYellow</span>(<span class="hljs-params">entries, observer</span>) {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
        $(entry.<span class="hljs-property">target</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>);
    });
}
</code></pre><p>最后传入观察者，即<code>.target</code>元素</p>
<pre><code class="hljs language-js">$targets.<span class="hljs-title function_">each</span>(<span class="hljs-function">(<span class="hljs-params">index, element</span>) =&gt;</span> {
    observer.<span class="hljs-title function_">observe</span>(element);
});
</code></pre><p>可以看到功能同样完成，并且页面不会出现卡顿的情况</p>
</details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">请解释 Nuxt3 中 nitro 的作用及关键配置项</h4><div class="head-re"><span class="head-score">8 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><details>

<ul>
<li><strong>2：</strong> nitro 负责 Nuxt3 服务器端构建与部署核心支撑、服务端渲染（SSR）及性能优化、灵活的路由处理与适配、跨平台与多环境适配</li>
<li><strong>1：</strong> 指定服务器的预设模式，决定了 Nuxt3 应用最终如何构建以及适配何种类型的运行环境。例：</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">preset</span>: <span class="hljs-string">&#x27;node-server&#x27;</span>
  }
}
<span class="hljs-comment">//在上述配置中，选择 node-server 预设，表示应用将以适合在传统 Node.js 服务器上运行的方式进行构建，生成对应的可执行代码和相关配置。如果设置为 serverless，</span>
<span class="hljs-comment">// 例如 preset: &#x27;serverless&#x27;，则会按照无服务器架构的要求对应用进行构建，以便能够部署到像 AWS Lambda 这样的无服务器环境中，nitro 会自动处理相关的代码打包、资源管理等差异，确保应用正常运行。</span>
</code></pre><ul>
<li><strong>2：</strong> routeRules,用于详细定义各个路由的规则，涵盖缓存策略、重定向规则、响应头设置等方面，能够根据具体的业务需求对不同路由进行定制化配置，优化路由相关的性能和用户访问逻辑。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">routeRules</span>: {
      <span class="hljs-string">&#x27;/&#x27;</span>: {
        <span class="hljs-attr">cache</span>: {
          <span class="hljs-attr">maxAge</span>: <span class="hljs-number">60</span> * <span class="hljs-number">10</span> <span class="hljs-comment">// 为首页设置缓存时间，这里是 10 分钟</span>
        }
      },
      <span class="hljs-string">&#x27;/about&#x27;</span>: {
        <span class="hljs-attr">redirect</span>: {
          <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-comment">// 将访问 /about 页面重定向到首页</span>
          <span class="hljs-attr">statusCode</span>: <span class="hljs-number">302</span>
        }
      },
      <span class="hljs-string">&#x27;/api/data&#x27;</span>: {
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment">// 为 /api/data 路由设置响应头，允许跨域访问</span>
        }
      }
    }
  }
}
<span class="hljs-comment">//在这个示例中，针对应用的根路由（/）设置了缓存策略，即用户首次访问后，在接下来的 10 分钟内再次访问该页面时，服务器可以直接从缓存中获取页面内容并返回，减</span>
<span class="hljs-comment">// 少服务器处理负担；对于 /about 页面配置了重定向规则，当用户访问该页面时会以 302 状态码重定向到首页；而 /api/data 路由则通过设置响应头，解决了该路由的跨域访问问题，方便前端与之交互。</span>
</code></pre><ul>
<li><strong>1：</strong> devProxy, 主要在开发环境中发挥作用，用于配置代理服务器，将前端应用发出的请求代理转发到指定的后端服务器地址，以此巧妙地解决开发过程中常见的跨域问题，使得前后端能够在本地
开发环境下顺畅地协同工作。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">devProxy</span>: {
      <span class="hljs-string">&#x27;/api&#x27;</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/api&#x27;</span>, <span class="hljs-comment">// 后端 API 服务器的实际地址</span>
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
      }
    }
  }
}
</code></pre><ul>
<li><strong>1：</strong> output, 可以对构建输出的相关参数进行配置，包括指定构建输出的目录、公共资源目录的设置、确定模块格式等内容，让开发者能够根据项目的实际部署需求以及目标环境的
要求，精准地定制构建结果的呈现形式。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-comment">// 设置构建输出目录为 dist</span>
      <span class="hljs-attr">publicDir</span>: <span class="hljs-string">&#x27;public&#x27;</span>, <span class="hljs-comment">// 设定公共资源目录为 public</span>
      <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;esm&#x27;</span> <span class="hljs-comment">// 设置模块格式为 ESM（ECMAScript 模块），也可根据需求选择其他格式</span>
    }
  }
}
</code></pre><ul>
<li><strong>1：</strong> plugins, 允许开发者在 nitro 的构建流程中引入自定义的插件，这些插件能够扩展 nitro 的功能，执行诸如在服务器启动时初始化特定资源、修改请求和响应处理逻辑、与外部
系统进行集成等操作，从而为服务器端应用增添更多的灵活性和可定制性。</li>
</ul>
<pre><code class="hljs language-ts"><span class="hljs-comment">// nuxt.config.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">nitro</span>: {
    <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;./server/plugins/myPlugin.ts&#x27;</span>]
  }
}
</code></pre></details>

</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">17. CSS3中有哪些新特性</h4><div class="head-re"><span class="head-score">3 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 拓展</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</p>
</li>
<li><p>圆角 （border-radius:8px）</p>
</li>
<li><p>多列布局 （multi-column layout）</p>
</li>
<li><p>阴影和反射 （box-shadow 和 reflect）</p>
</li>
<li><p>文字特效 （text-shadow）</p>
</li>
<li><p>线性渐变 （gradient）</p>
</li>
<li><p>旋转 （transform）</p>
</li>
<li><p>媒体查询 （@media）</p>
</li>
<li><p>2D、3D 转换和动画</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">52. 为什么会出现浮动? 什么时候需要清除浮动？清除浮动有哪些方式？优缺点是什么？你认为最好的是哪一种？为什么？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>出现浮动的原因：</p>
<p>浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。</p>
<p>关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。</p>
<p>浮动带来的问题：</p>
<ul>
<li><p>父元素的高度无法被撑开，影响与父元素同级的元素</p>
</li>
<li><p>与浮动元素同级的非浮动元素（内联元素）会跟随其后</p>
</li>
<li><p>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p>
</li>
</ul>
<p>清除浮动的方式：</p>
<ul>
<li><p>父级div定义height</p>
</li>
<li><p>最后一个浮动元素后加空div标签并设置属性 clear:both</p>
</li>
<li><p>包含浮动元素的父标签添加样式 overflow:hidden</p>
</li>
<li><p>父级div定义伪类:after 和 zoom</p>
</li>
<li><p>父级div定义伪类:after 和 display:table</p>
</li>
<li><p>父级div定义伪元素:after 和 content:” “</p>
</li>
</ul>
<p>最好的方式是给父元素添加overflow:hidden</p>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">32. 使用Hooks要遵守哪些原则？</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 编程</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>只在最顶层使用 Hook  不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</p>
</li>
<li><p>只在 React 函数中调用 Hook</p>
</li>
</ul>
<p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p>
<ul>
<li><p>在 React 的函数组件中调用 Hook</p>
</li>
<li><p>在自定义 Hook 中调用其他 Hook</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">44. 页面刷新了之后vuex中的数据消失怎么解决</h4><div class="head-re"><span class="head-score">2 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><ul>
<li><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>
</li>
<li><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p>
</li>
</ul>
</details></div><div class="main-box_inner"><div class="inner-head"><h4 class="head-title">head 标签有什么作用，其中什么标签必不可少？</h4><div class="head-re"><span class="head-score">1 分</span><input class="head-statistics" type="number" step="1"></div></div><div class="head-tips">类型 基础</div><div class="head-tips">级别: `W1`、`W2`、`W3`、`W4`、`W5`、`W6`</div><details class="inner-content"><p>标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：meta, link 等。</p>
</details></div><div class="content-scoring"><span>总得分：</span><span class="scoring-num">0</span><button class="export-excel">导出到Excel</button></div></div></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><div class="edit-info" data-v-1bcd8184><!----><div class="last-updated" data-v-1bcd8184><p class="VPLastUpdated" data-v-1bcd8184 data-v-1bb0c8a8>最后更新于: <time datetime="2025-02-19T08:25:20.000Z" data-v-1bb0c8a8></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/mb-front-end-interview/src/training/training-senior/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>上一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/mb-front-end-interview/src/training/training-experts/index.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>下一页</span><span class="title" data-v-1bcd8184>开始训练</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>基于 MIT 许可发布</p><p class="copyright" data-v-566314d4>版权所有 © 2024-2025 ShanYi-Hui</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"B6C6C3q1\",\"ing.md\":\"DKXDxiBe\",\"readme.md\":\"B5aY4z-c\",\"src_guide_getting-started.md\":\"Df5p00SW\",\"src_guide_why.md\":\"6xPcNhtH\",\"src_questions_artificial-intelligence_1_基础理论.md\":\"sHCFR5Vi\",\"src_questions_artificial-intelligence_2_基础应用.md\":\"DuJJ5nh5\",\"src_questions_computer-base_1_计算机硬件.md\":\"C9j1pwBv\",\"src_questions_computer-base_2_计算机软件.md\":\"DYtLtfZV\",\"src_questions_computer-base_3_计算机网络.md\":\"B2rr2pZv\",\"src_questions_computer-base_4_计算机编程.md\":\"CZBP0p74\",\"src_questions_computer-base_5_计算机科学.md\":\"DwPPJIw3\",\"src_questions_computer-base_6_软件工程.md\":\"fN7IZOyF\",\"src_questions_computer-base_7_计算机系统 mac.md\":\"fmMSNglb\",\"src_questions_computer-base_8_计算机系统 windows.md\":\"D7TIO1MH\",\"src_questions_data-structures-algorithms_1_算法.md\":\"BC7_hH7e\",\"src_questions_front-architect_1_前端架构.md\":\"D2QYcOW2\",\"src_questions_front-base_1_html.md\":\"BNmiBymH\",\"src_questions_front-base_2_css.md\":\"DQ9ArW1U\",\"src_questions_front-base_3_javascript.md\":\"uESgcf8T\",\"src_questions_front-base_4_typescript.md\":\"U8oRwKPq\",\"src_questions_front-component_1_ui组件库.md\":\"BHTG7C9m\",\"src_questions_front-component_2_业务组件库.md\":\"xaLMXoyU\",\"src_questions_front-engineering_1_前端标准化.md\":\"DltENx9M\",\"src_questions_front-engineering_2_前端自动化.md\":\"CQNjvrfQ\",\"src_questions_front-engineering_3_webpack.md\":\"ClRf3iQL\",\"src_questions_front-engineering_4_vite.md\":\"CNP6urDF\",\"src_questions_front-engineering_5_rollup.md\":\"Bbk7jUvc\",\"src_questions_front-frame_1_react.md\":\"BtDdr_DI\",\"src_questions_front-frame_2_vue.md\":\"C2RMpUnk\",\"src_questions_front-frame_3_next.md\":\"DzSwBmLT\",\"src_questions_front-frame_4_nuxt.md\":\"DdeWg_s3\",\"src_questions_front-frame_5_qiankun.md\":\"DVsFHGqG\",\"src_questions_front-newest_1_前端最前沿.md\":\"BXMs1cou\",\"src_questions_front-perfomance_1_前端性能优化.md\":\"DXsf4hS_\",\"src_questions_front-runtime_1_浏览器.md\":\"D3nT1IBV\",\"src_questions_front-runtime_2_nodejs.md\":\"CbFqLoT0\",\"src_questions_front-safety_1_前端安全.md\":\"DhTP7Y30\",\"src_questions_server_1_nest.md\":\"C8ky73FR\",\"src_questions_server_2_mongodb.md\":\"w8Rs341E\",\"src_questions_server_3_mysql.md\":\"CGOaUDai\",\"src_questions_server_4_nginx.md\":\"4Pyp0BTX\",\"src_questions_server_5_docker.md\":\"CuCGPMOU\",\"src_questions_server_6_kubernets.md\":\"3qYaZT71\",\"src_questions_server_7_nacos.md\":\"B-nkL4DG\",\"src_questions_server_8_redis.md\":\"s_torjG_\",\"src_training_training-architecture_index.md\":\"Ckz7gu8O\",\"src_training_training-experts_index.md\":\"CIsXyvxd\",\"src_training_training-intermediate_index.md\":\"CzLwuPok\",\"src_training_training-primary_index.md\":\"Do0HgD2o\",\"src_training_training-senior_index.md\":\"Br3TkKy0\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端面试题库\",\"description\":\"致力于为前端人员提供全面可靠的专业知识\",\"base\":\"/mb-front-end-interview/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"指南\",\"link\":\"/src/guide/why\",\"activeMatch\":\"/src/guide/\"},{\"text\":\"题库\",\"link\":\"/src/questions/front-base/1_HTML\",\"activeMatch\":\"/src/questions/\"},{\"text\":\"训练\",\"link\":\"/src/training/training-primary/index\",\"activeMatch\":\"/src/training/\"}],\"sidebar\":{\"/src/guide/\":[{\"text\":\"初衷\",\"link\":\"/src/guide/why\"},{\"text\":\"快速开始\",\"link\":\"/src/guide/getting-started\"}],\"/src/questions/\":[{\"text\":\"前端基础\",\"collapsed\":false,\"items\":[{\"text\":\"HTML\",\"link\":\"/src/questions/front-base/1_HTML.md\"},{\"text\":\"CSS\",\"link\":\"/src/questions/front-base/2_CSS.md\"},{\"text\":\"JavaScript\",\"link\":\"/src/questions/front-base/3_JavaScript.md\"},{\"text\":\"TypeScript\",\"link\":\"/src/questions/front-base/4_TypeScript.md\"}]},{\"text\":\"前端运行环境\",\"collapsed\":true,\"items\":[{\"text\":\"浏览器\",\"link\":\"/src/questions/front-runtime/1_浏览器.md\"},{\"text\":\"NodeJS\",\"link\":\"/src/questions/front-runtime/2_NodeJS.md\"}]},{\"text\":\"前端框架\",\"collapsed\":true,\"items\":[{\"text\":\"React\",\"link\":\"/src/questions/front-frame/1_React.md\"},{\"text\":\"Vue\",\"link\":\"/src/questions/front-frame/2_Vue.md\"},{\"text\":\"Next\",\"link\":\"/src/questions/front-frame/3_Next.md\"},{\"text\":\"Nuxt\",\"link\":\"/src/questions/front-frame/4_Nuxt.md\"},{\"text\":\"Qiankun\",\"link\":\"/src/questions/front-frame/5_Qiankun.md\"}]},{\"text\":\"前端工程化\",\"collapsed\":true,\"items\":[{\"text\":\"前端标准化\",\"link\":\"/src/questions/front-engineering/1_前端标准化.md\"},{\"text\":\"前端自动化\",\"link\":\"/src/questions/front-engineering/2_前端自动化.md\"},{\"text\":\"Webpack\",\"link\":\"/src/questions/front-engineering/3_Webpack.md\"},{\"text\":\"Vite\",\"link\":\"/src/questions/front-engineering/4_Vite.md\"},{\"text\":\"Rollup\",\"link\":\"/src/questions/front-engineering/5_Rollup.md\"}]},{\"text\":\"前端组件库\",\"collapsed\":true,\"items\":[{\"text\":\"UI组件库\",\"link\":\"/src/questions/front-component/1_UI组件库.md\"},{\"text\":\"业务组件库\",\"link\":\"/src/questions/front-component/2_业务组件库.md\"}]},{\"text\":\"前端安全\",\"collapsed\":true,\"items\":[{\"text\":\"前端安全\",\"link\":\"/src/questions/front-safety/1_前端安全.md\"}]},{\"text\":\"前端性能\",\"collapsed\":true,\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/src/questions/front-perfomance/1_前端性能优化.md\"}]},{\"text\":\"前端架构\",\"collapsed\":true,\"items\":[{\"text\":\"前端架构\",\"link\":\"/src/questions/front-architect/1_前端架构.md\"}]},{\"text\":\"服务端\",\"collapsed\":true,\"items\":[{\"text\":\"Nest\",\"link\":\"/src/questions/server/1_Nest.md\"},{\"text\":\"MongoDB\",\"link\":\"/src/questions/server/2_MongoDB.md\"},{\"text\":\"MySQL\",\"link\":\"/src/questions/server/3_MySQL.md\"},{\"text\":\"Nginx\",\"link\":\"/src/questions/server/4_Nginx.md\"},{\"text\":\"Docker\",\"link\":\"/src/questions/server/5_Docker.md\"},{\"text\":\"Kubernets\",\"link\":\"/src/questions/server/6_Kubernets.md\"},{\"text\":\"Nacos\",\"link\":\"/src/questions/server/7_Nacos.md\"},{\"text\":\"Redis\",\"link\":\"/src/questions/server/8_Redis.md\"}]},{\"text\":\"数据结构及算法\",\"collapsed\":true,\"items\":[{\"text\":\"算法\",\"link\":\"/src/questions/data-structures-algorithms/1_算法.md\"}]},{\"text\":\"前端最前沿\",\"collapsed\":true,\"items\":[{\"text\":\"前端最前沿\",\"link\":\"/src/questions/front-newest/1_前端最前沿.md\"}]},{\"text\":\"计算机基础\",\"collapsed\":true,\"items\":[{\"text\":\"计算机硬件\",\"link\":\"/src/questions/computer-base/1_计算机硬件.md\"},{\"text\":\"计算机软件\",\"link\":\"/src/questions/computer-base/2_计算机软件.md\"},{\"text\":\"计算机网络\",\"link\":\"/src/questions/computer-base/3_计算机网络.md\"},{\"text\":\"计算机编程\",\"link\":\"/src/questions/computer-base/4_计算机编程.md\"},{\"text\":\"计算机科学\",\"link\":\"/src/questions/computer-base/5_计算机科学.md\"},{\"text\":\"软件工程\",\"link\":\"/src/questions/computer-base/6_软件工程.md\"},{\"text\":\"计算机系统 Mac\",\"link\":\"/src/questions/computer-base/7_计算机系统 Mac.md\"},{\"text\":\"计算机系统 Windows\",\"link\":\"/src/questions/computer-base/8_计算机系统 Windows.md\"}]},{\"text\":\"人工智能\",\"collapsed\":true,\"items\":[{\"text\":\"基础理论\",\"link\":\"/src/questions/artificial-intelligence/1_基础理论.md\"},{\"text\":\"基础应用\",\"link\":\"/src/questions/artificial-intelligence/2_基础应用.md\"}]}],\"/src/training/\":[{\"text\":\"初级\",\"collapsed\":false,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-primary/index.md\"}]},{\"text\":\"中级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-intermediate/index.md\"}]},{\"text\":\"高级\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-senior/index.md\"}]},{\"text\":\"架构\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-architecture/index.md\"}]},{\"text\":\"专家\",\"collapsed\":true,\"items\":[{\"text\":\"开始训练\",\"link\":\"/src/training/training-experts/index.md\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/syh-micro-build/mb-front-end-interview\"}],\"footer\":{\"message\":\"基于 MIT 许可发布\",\"copyright\":\"版权所有 © 2024-2025 ShanYi-Hui\"},\"docFooter\":{\"prev\":\"上一页\",\"next\":\"下一页\"},\"outline\":{\"label\":\"页面导航\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"short\",\"timeStyle\":\"medium\"}},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\",\"closeText\":\"关闭\"}}}}},\"returnToTopLabel\":\"回到顶部\",\"sidebarMenuLabel\":\"菜单\",\"darkModeSwitchLabel\":\"主题\",\"lightModeSwitchTitle\":\"切换到浅色模式\",\"darkModeSwitchTitle\":\"切换到深色模式\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>